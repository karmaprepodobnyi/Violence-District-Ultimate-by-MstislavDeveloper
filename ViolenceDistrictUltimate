ммммммммммммммммммммммммммммммммммммlocal Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Lighting = game:GetService("Lighting")
local Teams = game:GetService("Teams")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")
local CoreGui = game:GetService("CoreGui")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local _F = {}

_F._cache = {}
_F._connections = {}
_F._espCache = {}
_F._lastUpdate = 0
_F._updateInterval = 0.1

-- Создание основного GUI
_F.ScreenGui = Instance.new("ScreenGui")
_F.ScreenGui.Name = "ViolenceDistrictMenu"
_F.ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

pcall(function()
    _F.ScreenGui.Parent = CoreGui
end)

-- Основной фрейм меню
_F.MainFrame = Instance.new("Frame")
_F.MainFrame.Name = "MainFrame"
_F.MainFrame.Size = UDim2.new(0, 450, 0, 650)
_F.MainFrame.Position = UDim2.new(0, 20, 0, 100)
_F.MainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
_F.MainFrame.BorderSizePixel = 0
_F.MainFrame.ClipsDescendants = true
_F.MainFrame.Parent = _F.ScreenGui

-- Переменные для перетаскивания
_F.dragging = false
_F.dragInput = nil
_F.dragStart = nil
_F.startPos = nil

-- Оптимизированная функция для перетаскивания
_F.update = function(input)
    if _F.dragging then
        local delta = input.Position - _F.dragStart
        _F.MainFrame.Position = UDim2.new(_F.startPos.X.Scale, _F.startPos.X.Offset + delta.X, _F.startPos.Y.Scale, _F.startPos.Y.Offset + delta.Y)
    end
end

_F.MainFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        _F.dragging = true
        _F.dragStart = input.Position
        _F.startPos = _F.MainFrame.Position
    end
end)

_F.MainFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        _F.dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == _F.dragInput and _F.dragging then
        _F.update(input)
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        _F.dragging = false
    end
end)

-- Скругление углов
_F.UICorner = Instance.new("UICorner")
_F.UICorner.CornerRadius = UDim.new(0, 12)
_F.UICorner.Parent = _F.MainFrame

-- Тень
_F.UIStroke = Instance.new("UIStroke")
_F.UIStroke.Color = Color3.fromRGB(60, 60, 70)
_F.UIStroke.Thickness = 2
_F.UIStroke.Parent = _F.MainFrame

-- Заголовок
_F.TitleFrame = Instance.new("Frame")
_F.TitleFrame.Name = "TitleFrame"
_F.TitleFrame.Size = UDim2.new(1, 0, 0, 40)
_F.TitleFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
_F.TitleFrame.BorderSizePixel = 0
_F.TitleFrame.Parent = _F.MainFrame

_F.TitleCorner = Instance.new("UICorner")
_F.TitleCorner.CornerRadius = UDim.new(0, 12)
_F.TitleCorner.Parent = _F.TitleFrame

_F.TitleLabel = Instance.new("TextLabel")
_F.TitleLabel.Name = "TitleLabel"
_F.TitleLabel.Size = UDim2.new(1, 0, 1, 0)
_F.TitleLabel.BackgroundTransparency = 1
_F.TitleLabel.Text = "VIOLENCE DISTRICT ULTIMATE"
_F.TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
_F.TitleLabel.TextSize = 16
_F.TitleLabel.Font = Enum.Font.GothamBold
_F.TitleLabel.Parent = _F.TitleFrame

-- Вкладки меню
_F.TabButtonsFrame = Instance.new("Frame")
_F.TabButtonsFrame.Name = "TabButtonsFrame"
_F.TabButtonsFrame.Size = UDim2.new(1, -30, 0, 30)
_F.TabButtonsFrame.Position = UDim2.new(0, 15, 0, 45)
_F.TabButtonsFrame.BackgroundTransparency = 1
_F.TabButtonsFrame.Parent = _F.MainFrame

_F.TabButtonsLayout = Instance.new("UIListLayout")
_F.TabButtonsLayout.FillDirection = Enum.FillDirection.Horizontal
_F.TabButtonsLayout.Padding = UDim.new(0, 5)
_F.TabButtonsLayout.Parent = _F.TabButtonsFrame

-- Контентная область
_F.ContentFrame = Instance.new("Frame")
_F.ContentFrame.Name = "ContentFrame"
_F.ContentFrame.Size = UDim2.new(1, -30, 1, -90)
_F.ContentFrame.Position = UDim2.new(0, 15, 0, 80)
_F.ContentFrame.BackgroundTransparency = 1
_F.ContentFrame.Parent = _F.MainFrame

-- Фреймы для разных разделов
_F.ESPSettingsFrame = Instance.new("ScrollingFrame")
_F.ESPSettingsFrame.Name = "ESPSettingsFrame"
_F.ESPSettingsFrame.Size = UDim2.new(1, 0, 1, 0)
_F.ESPSettingsFrame.BackgroundTransparency = 1
_F.ESPSettingsFrame.ScrollBarThickness = 4
_F.ESPSettingsFrame.ScrollBarImageColor3 = Color3.fromRGB(80, 80, 90)
_F.ESPSettingsFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
_F.ESPSettingsFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
_F.ESPSettingsFrame.Visible = true
_F.ESPSettingsFrame.Parent = _F.ContentFrame

_F.ESPColorsFrame = Instance.new("ScrollingFrame")
_F.ESPColorsFrame.Name = "ESPColorsFrame"
_F.ESPColorsFrame.Size = UDim2.new(1, 0, 1, 0)
_F.ESPColorsFrame.BackgroundTransparency = 1
_F.ESPColorsFrame.ScrollBarThickness = 4
_F.ESPColorsFrame.ScrollBarImageColor3 = Color3.fromRGB(80, 80, 90)
_F.ESPColorsFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
_F.ESPColorsFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
_F.ESPColorsFrame.Visible = false
_F.ESPColorsFrame.Parent = _F.ContentFrame

_F.GameFeaturesFrame = Instance.new("ScrollingFrame")
_F.GameFeaturesFrame.Name = "GameFeaturesFrame"
_F.GameFeaturesFrame.Size = UDim2.new(1, 0, 1, 0)
_F.GameFeaturesFrame.BackgroundTransparency = 1
_F.GameFeaturesFrame.ScrollBarThickness = 4
_F.GameFeaturesFrame.ScrollBarImageColor3 = Color3.fromRGB(80, 80, 90)
_F.GameFeaturesFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
_F.GameFeaturesFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
_F.GameFeaturesFrame.Visible = false
_F.GameFeaturesFrame.Parent = _F.ContentFrame

_F.VisualSettingsFrame = Instance.new("ScrollingFrame")
_F.VisualSettingsFrame.Name = "VisualSettingsFrame"
_F.VisualSettingsFrame.Size = UDim2.new(1, 0, 1, 0)
_F.VisualSettingsFrame.BackgroundTransparency = 1
_F.VisualSettingsFrame.ScrollBarThickness = 4
_F.VisualSettingsFrame.ScrollBarImageColor3 = Color3.fromRGB(80, 80, 90)
_F.VisualSettingsFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
_F.VisualSettingsFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
_F.VisualSettingsFrame.Visible = false
_F.VisualSettingsFrame.Parent = _F.ContentFrame

-- Layout для фреймов
_F.ESPLayout = Instance.new("UIListLayout")
_F.ESPLayout.Padding = UDim.new(0, 15)
_F.ESPLayout.Parent = _F.ESPSettingsFrame

_F.ColorsLayout = Instance.new("UIListLayout")
_F.ColorsLayout.Padding = UDim.new(0, 15)
_F.ColorsLayout.Parent = _F.ESPColorsFrame

_F.FeaturesLayout = Instance.new("UIListLayout")
_F.FeaturesLayout.Padding = UDim.new(0, 15)
_F.FeaturesLayout.Parent = _F.GameFeaturesFrame

_F.VisualLayout = Instance.new("UIListLayout")
_F.VisualLayout.Padding = UDim.new(0, 15)
_F.VisualLayout.Parent = _F.VisualSettingsFrame

-- Переменные для состояния меню
_F._lastGeneratorCheck = 0
_F._lastPalletCheck = 0
_F.AutoRefreshConnection = nil

-- Переменные для Third Person View
_F.ThirdPersonEnabled = false
_F.ThirdPersonConnection = nil
_F.OriginalCameraType = nil

-- Переменные для Rotate Person
_F.RotatePersonEnabled = false
_F.RotateSpeed = 100
_F.RotateConnection = nil

_F.MenuOpen = true
_F.ESPEnabled = false
_F.GeneratorESPEnabled = false
_F.PalletESPEnabled = false
_F.SuperESPEnabled = false
_F.AutoUpdateEnabled = true
_F.MapLoaded = false
_F.GameStarted = false
_F.CrosshairEnabled = false
_F.walkSpeedActive = false
_F.walkSpeed = 16
_F.JumpPowerEnabled = false
_F.JumpPowerValue = 50
_F.JumpPowerConnection = nil
_F.FlyEnabled = false
_F.FlySpeedValue = 50
_F.NoclipEnabled = false
_F.NoclipConnection = nil
_F.NoclipCharacterConnection = nil
_F.GodModeEnabled = false
_F.InvisibleEnabled = false
_F.AntiStunEnabled = false
_F.AntiGrabEnabled = false
_F.MaxEscapeChanceEnabled = false
_F.GrabKillerEnabled = false
_F.RapidFireEnabled = false
_F.DisableTwistAnimationsEnabled = false
_F.NoFogEnabled = false
_F.TimeEnabled = false
_F.TimeValue = 12
_F.MapColorEnabled = false
_F.MapColor = Color3.fromRGB(255, 255, 255)
_F.MapColorSaturation = 1
_F.SurvivorColor = Color3.fromRGB(0, 255, 0)
_F.KillerColor = Color3.fromRGB(255, 0, 0)
_F.GeneratorColor = Color3.fromRGB(0, 100, 255)
_F.PalletColor = Color3.fromRGB(255, 255, 0)
_F.RGBESPEnabled = false
_F.RGBESPSpeed = 1
_F.SuperESPSpeed = 1
_F.AimbotEnabled = false
_F.AimbotConnection = nil
_F.AimbotTarget = nil
_F.AimbotFOV = 50
_F.AimbotSmoothness = 10
_F.AimbotTeamCheck = true
_F.AimbotVisibleCheck = true
_F.AimbotKey = Enum.UserInputType.MouseButton2


_F.TeleportEnabled = false
_F.TeleportFrame = nil
_F.TeleportPlayersFrame = nil
_F.TeleportPlayers = {}

-- Переменные для функций
_F.Flying = false
_F.BodyVelocity = nil
_F.BodyGyro = nil
_F.FlyConnection = nil
_F.NoclipConnection = nil
_F.GodModeConnection = nil
_F.AntiStunConnection = nil
_F.AntiGrabConnection = nil
_F.EscapeChanceConnection = nil
_F.GrabKillerConnection = nil
_F.RapidFireConnection = nil
_F.AutoRefreshConnection = nil
_F.TwistAnimationsConnection = nil
_F.NoFogConnection = nil
_F.TimeConnection = nil
_F.MapColorConnection = nil
_F.RGBESPConnection = nil
_F.SuperESPConnection = nil

-- ESP объекты
_F.ESPFolders = {}
_F.ESPConnections = {}
_F.GeneratorESPItems = {}
_F.PalletESPItems = {}

-- Прицел-точка
_F.CrosshairFrame = Instance.new("Frame")
_F.CrosshairFrame.Name = "Crosshair"
_F.CrosshairFrame.Size = UDim2.new(0, 20, 0, 20)
_F.CrosshairFrame.Position = UDim2.new(0.5, -10, 0.5, -10)
_F.CrosshairFrame.BackgroundTransparency = 1
_F.CrosshairFrame.Visible = false
_F.CrosshairFrame.ZIndex = 1000
_F.CrosshairFrame.Parent = _F.ScreenGui

_F.CrosshairDot = Instance.new("Frame")
_F.CrosshairDot.Name = "CrosshairDot"
_F.CrosshairDot.Size = UDim2.new(0, 4, 0, 4)
_F.CrosshairDot.Position = UDim2.new(0.5, -2, 0.5, -2)
_F.CrosshairDot.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
_F.CrosshairDot.BorderSizePixel = 0
_F.CrosshairDot.Parent = _F.CrosshairFrame

_F.CrosshairCorner = Instance.new("UICorner")
_F.CrosshairCorner.CornerRadius = UDim.new(0, 2)
_F.CrosshairCorner.Parent = _F.CrosshairDot

-- Глобальные соединения
_F.PlayerAddedConnection = nil
_F.MapChecker = nil
_F.GameStartChecker = nil
_F.GameStateChecker = nil
_F.LastGameState = ""

-- Выносим тяжелые функции в отдельные таблицы
_F.AimbotFunctions = {}
_F.ESPFunctions = {}
_F.MovementFunctions = {}

-- Выносим JumpPower в отдельную таблицу
_F.MovementFunctions.UpdateJumpPowerValue = function(value)
    _F.JumpPowerValue = value
    print("JumpPower value changed to: " .. value)
    if _F.JumpPowerEnabled then
        _F.UpdateJumpPower()
    end
end

-- Функция создания кнопки вкладки
_F.CreateTabButton = function(name, targetFrame)
    local TabButton = Instance.new("TextButton")
    TabButton.Name = name .. "Tab"
    TabButton.Size = UDim2.new(0.25, -5, 1, 0)
    TabButton.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    TabButton.BorderSizePixel = 0
    TabButton.Text = name
    TabButton.TextColor3 = Color3.fromRGB(200, 200, 200)
    TabButton.TextSize = 12
    TabButton.Font = Enum.Font.GothamBold
    TabButton.Parent = _F.TabButtonsFrame
    
    local TabCorner = Instance.new("UICorner")
    TabCorner.CornerRadius = UDim.new(0, 6)
    TabCorner.Parent = TabButton
    
    TabButton.MouseButton1Click:Connect(function()
        -- Скрыть все фреймы
        _F.ESPSettingsFrame.Visible = false
        _F.ESPColorsFrame.Visible = false
        _F.GameFeaturesFrame.Visible = false
        _F.VisualSettingsFrame.Visible = false
        
        -- Показать целевой фрейм
        targetFrame.Visible = true
        
        -- Обновить цвета кнопок
        for _, child in ipairs(_F.TabButtonsFrame:GetChildren()) do
            if child:IsA("TextButton") then
                child.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
                child.TextColor3 = Color3.fromRGB(200, 200, 200)
            end
        end
        
        -- Подсветить активную кнопку
        TabButton.BackgroundColor3 = Color3.fromRGB(0, 100, 255)
        TabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    end)
    
    return TabButton
end

-- Создание вкладок
_F.ESPTab = _F.CreateTabButton("ESP", _F.ESPSettingsFrame)
_F.ColorsTab = _F.CreateTabButton("COLORS", _F.ESPColorsFrame)
_F.FeaturesTab = _F.CreateTabButton("FEATURES", _F.GameFeaturesFrame)
_F.VisualTab = _F.CreateTabButton("VISUAL", _F.VisualSettingsFrame)

-- Активируем первую вкладку по умолчанию
_F.ESPTab.BackgroundColor3 = Color3.fromRGB(0, 100, 255)
_F.ESPTab.TextColor3 = Color3.fromRGB(255, 255, 255)

_F.MovementFunctions.ToggleJumpPower = function(enabled)
    _F.JumpPowerEnabled = enabled
    
    if _F.JumpPowerConnection then
        _F.JumpPowerConnection:Disconnect()
        _F.JumpPowerConnection = nil
    end
    
    if enabled then
        print("Enabling JumpPower...")
        _F.UpdateJumpPower()
        
        _F.JumpPowerConnection = LocalPlayer.CharacterAdded:Connect(function(character)
            print("New character detected, applying JumpPower...")
            
            for i = 1, 3 do
                wait(1)
                _F.UpdateJumpPower()
            end
            
            local humanoid = character:WaitForChild("Humanoid", 5)
            if humanoid then
                humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
                    if _F.JumpPowerEnabled and humanoid.JumpPower ~= _F.JumpPowerValue then
                        humanoid.JumpPower = _F.JumpPowerValue
                        print("JumpPower corrected: " .. _F.JumpPowerValue)
                    end
                end)
                
                while _F.JumpPowerEnabled and character and humanoid do
                    wait(2)
                    if humanoid.JumpPower ~= _F.JumpPowerValue then
                        humanoid.JumpPower = _F.JumpPowerValue
                        print("JumpPower force updated: " .. _F.JumpPowerValue)
                    end
                end
            end
        end)
        
        coroutine.wrap(function()
            while _F.JumpPowerEnabled do
                wait(3)
                _F.UpdateJumpPower()
            end
        end)()
        
    else
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.JumpPower = 50
            end
        end
        print("JumpPower: DISABLED")
    end
end

-- функция разблокировки курсора
_F.UnlockCursor = function()
    pcall(function()
        UserInputService.MouseIconEnabled = true
        if not _F.FlyEnabled then
            UserInputService.MouseBehavior = Enum.MouseBehavior.Default
        end
    end)
end

-- Улучшенная система проверки состояния игрока
_F.GetPlayerRole = function(player)
    if not player or player == LocalPlayer then return "Unknown" end
    
    -- Используем кэш для снижения нагрузки
    if _F._cache.roleCache and _F._cache.roleCache[player] and tick() - (_F._cache.roleCacheTime or 0) < 2 then
        return _F._cache.roleCache[player]
    end
    
    _F._cache.roleCache = _F._cache.roleCache or {}
    _F._cache.roleCacheTime = tick()
    
    local role = "Unknown"
    
    pcall(function()
        -- 1. Проверка команды (Team)
        if player.Team then
            local teamName = string.lower(player.Team.Name)
            if teamName == "spectator" or teamName == "spectators" then
                role = "Spectator"
                _F._cache.roleCache[player] = role
                return
            elseif teamName == "killer" or teamName == "murderer" or teamName == "hunter" then
                role = "Killer"
                _F._cache.roleCache[player] = role
                return
            elseif teamName == "survivor" or teamName == "civilian" or teamName == "victim" then
                role = "Survivor"
                _F._cache.roleCache[player] = role
                return
            end
        end
        
        -- 2. Проверка leaderstats
        local leaderstats = player:FindFirstChild("leaderstats")
        if leaderstats then
            local roleValue = leaderstats:FindFirstChild("Role") or leaderstats:FindFirstChild("Team") or leaderstats:FindFirstChild("Class")
            if roleValue then
                local roleText = string.lower(tostring(roleValue.Value))
                if string.find(roleText, "spectator") then
                    role = "Spectator"
                elseif string.find(roleText, "killer") or string.find(roleText, "murderer") or string.find(roleText, "hunter") then
                    role = "Killer"
                elseif string.find(roleText, "survivor") or string.find(roleText, "civilian") then
                    role = "Survivor"
                end
                _F._cache.roleCache[player] = role
                return
            end
        end
        
        -- 3. Проверка по оружию (только если игра активна)
        if _F.GameStarted then
            local function checkForWeapons(container)
                if not container then return false end
                local weaponKeywords = {"knife", "axe", "gun", "katana", "sword", "murder", "killer", "weapon"}
                
                for _, item in pairs(container:GetChildren()) do
                    if item:IsA("Tool") then
                        local toolName = string.lower(item.Name)
                        for _, keyword in ipairs(weaponKeywords) do
                            if string.find(toolName, keyword) then
                                return true
                            end
                        end
                    end
                end
                return false
            end
            
            local backpack = player:FindFirstChild("Backpack")
            local character = player.Character
            
            if backpack and checkForWeapons(backpack) then
                role = "Killer"
            elseif character and checkForWeapons(character) then
                role = "Killer"
            else
                role = "Survivor"
            end
        else
            -- В лобби все считаются Survivor если не Spectator
            role = "Survivor"
        end
        
        _F._cache.roleCache[player] = role
    end)
    
    return role
end

-- Улучшенная проверка является ли игрок Spectator
_F.IsPlayerSpectator = function(player)
    return _F.GetPlayerRole(player) == "Spectator"
end

-- Улучшенная проверка является ли игрок Killer
_F.IsPlayerKiller = function(player)
    return _F.GetPlayerRole(player) == "Killer"
end

-- Улучшенная проверка является ли игрок Survivor
_F.IsPlayerSurvivor = function(player)
    return _F.GetPlayerRole(player) == "Survivor"
end

-- Проверка валидности игрока для ESP
_F.IsValidPlayerForESP = function(player)
    if not player then return false end
    if player == LocalPlayer then return false end
    if _F.IsPlayerSpectator(player) then return false end
    
    -- Дополнительная проверка: игрок должен быть в игре
    if not _F.GameStarted then return false end
    
    return true
end

-- Улучшенная проверка начала игры
_F.CheckGameStarted = function()
    local success, result = pcall(function()
        -- Сбрасываем кэш ролей при проверке
        _F._cache.roleCache = {}
        
        local activePlayers = 0
        local hasKiller = false
        local hasSurvivors = false
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                local role = _F.GetPlayerRole(player)
                
                if role == "Killer" then
                    hasKiller = true
                    activePlayers = activePlayers + 1
                elseif role == "Survivor" then
                    hasSurvivors = true
                    activePlayers = activePlayers + 1
                end
                -- Spectators не считаются активными игроками
            end
        end
        
        -- Игра считается начатой если есть хотя бы 1 убийца и 1 выживший
        -- или если есть активные игроки и загружена карта
        return (hasKiller and hasSurvivors) or (activePlayers >= 2 and _F.MapLoaded)
    end)
    
    return success and result or false
end

-- Улучшенная проверка загрузки карты
_F.CheckMapLoaded = function()
    local success, result = pcall(function()
        -- Проверяем наличие игровых объектов
        local gameMarkers = {
            "Generators", "Generator", "Pallets", "Pallet", 
            "Exit", "Doors", "GameArea", "Map"
        }
        
        for _, marker in ipairs(gameMarkers) do
            if Workspace:FindFirstChild(marker) then
                return true
            end
        end
        
        -- Проверяем наличие игроков в активных ролях
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                local role = _F.GetPlayerRole(player)
                if role ~= "Spectator" and role ~= "Unknown" then
                    return true
                end
            end
        end
        
        return false
    end)
    
    return success and result or false
end

-- Улучшенная функция создания ESP
_F.CreateESP = function(player)
    if not _F.IsValidPlayerForESP(player) then
        _F.RemoveESP(player)
        return
    end
    
    -- Проверяем не создан ли уже ESP
    if _F.ESPFolders[player] then
        if _F.ESPFolders[player].Parent then
            return -- ESP уже существует
        else
            _F.ESPFolders[player] = nil -- Очищаем мусор
        end
    end
    
    local function setupCharacterESP(character)
        if not character or not character.Parent then
            _F.RemoveESP(player)
            return
        end
        
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 3)
        local humanoid = character:WaitForChild("Humanoid", 3)
        
        if not humanoidRootPart or not humanoid then
            _F.RemoveESP(player)
            return
        end
        
        -- Проверяем валидность игрока перед созданием ESP
        if not _F.IsValidPlayerForESP(player) then
            _F.RemoveESP(player)
            return
        end
        
        local role = _F.GetPlayerRole(player)
        local espColor = role == "Killer" and _F.KillerColor or _F.SurvivorColor
        local roleText = role == "Killer" and "KILLER" or "SURVIVOR"
        
        -- Создаем ESP folder
        local espFolder = Instance.new("Folder")
        espFolder.Name = player.Name .. "_ESP"
        espFolder.Parent = _F.ScreenGui
        
        -- Highlight
        local highlight = Instance.new("Highlight")
        highlight.Name = "ESPHighlight"
        highlight.Adornee = character
        highlight.FillColor = espColor
        highlight.FillTransparency = 0.3
        highlight.OutlineColor = espColor
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Parent = espFolder
        
        -- Billboard GUI
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "ESPBillboard"
        billboard.Adornee = humanoidRootPart
        billboard.Size = UDim2.new(0, 200, 0, 30)
        billboard.StudsOffset = Vector3.new(0, 3.5, 0)
        billboard.AlwaysOnTop = true
        billboard.Enabled = true
        billboard.Parent = espFolder
        
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Name = "ESPName"
        nameLabel.Size = UDim2.new(1, 0, 1, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.Text = player.Name .. " [" .. roleText .. "]"
        nameLabel.TextColor3 = espColor
        nameLabel.TextSize = 14
        nameLabel.Font = Enum.Font.GothamBold
        nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        nameLabel.TextStrokeTransparency = 0.3
        nameLabel.Parent = billboard
        
        _F.ESPFolders[player] = espFolder
        
        -- Соединения для отслеживания изменений
        local connections = {}
        
        connections.died = humanoid.Died:Connect(function()
            _F.RemoveESP(player)
        end)
        
        connections.characterRemoving = character.AncestryChanged:Connect(function(_, parent)
            if not parent then
                _F.RemoveESP(player)
            end
        end)
        
        _F.ESPConnections[player] = connections
    end
    
    -- Создаем ESP для текущего персонажа
    if player.Character then
        setupCharacterESP(player.Character)
    end
    
    -- Отслеживаем смену персонажа
    local characterConnection = player.CharacterAdded:Connect(function(newCharacter)
        wait(2) -- Ждем полной загрузки персонажа
        if _F.IsValidPlayerForESP(player) then
            setupCharacterESP(newCharacter)
        else
            _F.RemoveESP(player)
        end
    end)
    
    _F.ESPConnections[player] = _F.ESPConnections[player] or {}
    _F.ESPConnections[player].character = characterConnection
end

-- Улучшенная функция удаления ESP
_F.RemoveESP = function(player)
    if not player then return end
    
    -- Удаляем соединения
    if _F.ESPConnections[player] then
        for name, connection in pairs(_F.ESPConnections[player]) do
            if connection then
                connection:Disconnect()
            end
        end
        _F.ESPConnections[player] = nil
    end
    
    -- Удаляем ESP folder
    if _F.ESPFolders[player] then
        pcall(function()
            _F.ESPFolders[player]:Destroy()
        end)
        _F.ESPFolders[player] = nil
    end
end

-- Функция полной очистки ESP
_F.ClearAllESP = function()
    print("Clearing all ESP...")
    
    for player, _ in pairs(_F.ESPFolders) do
        _F.RemoveESP(player)
    end
    
    for generator, _ in pairs(_F.GeneratorESPItems) do
        _F.RemoveGeneratorESP(generator)
    end
    
    for pallet, _ in pairs(_F.PalletESPItems) do
        _F.RemovePalletESP(pallet)
    end
    
    _F.ESPFolders = {}
    _F.GeneratorESPItems = {}
    _F.PalletESPItems = {}
    _F.ESPConnections = {}
    
    print("All ESP cleared!")
end

-- Улучшенная функция обновления ESP
_F.UpdateESP = function()
    -- Очищаем невалидные ESP
    for player, espFolder in pairs(_F.ESPFolders) do
        if not _F.IsValidPlayerForESP(player) or not espFolder or not espFolder.Parent then
            _F.RemoveESP(player)
        end
    end
    
    -- Обновляем существующие ESP
    for player, espFolder in pairs(_F.ESPFolders) do
        if player and espFolder and espFolder.Parent and player.Character then
            local role = _F.GetPlayerRole(player)
            local espColor = role == "Killer" and _F.KillerColor or _F.SurvivorColor
            local roleText = role == "Killer" and "KILLER" or "SURVIVOR"
            
            local highlight = espFolder:FindFirstChild("ESPHighlight")
            local billboard = espFolder:FindFirstChild("ESPBillboard")
            
            if highlight then
                highlight.FillColor = espColor
                highlight.OutlineColor = espColor
            end
            
            if billboard then
                local nameLabel = billboard:FindFirstChild("ESPName")
                if nameLabel then
                    nameLabel.TextColor3 = espColor
                    nameLabel.Text = player.Name .. " [" .. roleText .. "]"
                end
            end
        else
            _F.RemoveESP(player)
        end
    end
end

-- Автоматическая очистка ESP при изменении состояния игры
_F.OnGameStateChanged = function()
    if not _F.GameStarted then
        -- Игра закончилась - очищаем ESP
        _F.ClearAllESP()
    else
        -- Игра началась - обновляем ESP
        if _F.ESPEnabled then
            _F.ForceUpdateAllESP()
        end
    end
end

-- Улучшенный запуск проверки игры
_F.StartGameCheckers = function()
    if _F.MapChecker then _F.MapChecker:Disconnect() end
    if _F.GameStartChecker then _F.GameStartChecker:Disconnect() end
    
    local lastGameState = _F.GameStarted
    
    _F.GameStartChecker = RunService.Heartbeat:Connect(function()
        if tick() - (_F._cache.lastGameCheck or 0) > 3 then -- Увеличили интервал
            _F._cache.lastGameCheck = tick()
            
            local currentMapState = _F.CheckMapLoaded()
            if currentMapState ~= _F.MapLoaded then
                _F.MapLoaded = currentMapState
                print("Map state changed: " .. tostring(_F.MapLoaded))
            end
            
            local currentGameState = _F.CheckGameStarted()
            if currentGameState ~= _F.GameStarted then
                _F.GameStarted = currentGameState
                print("Game state changed: " .. tostring(_F.GameStarted))
                
                -- Очищаем кэш ролей при смене состояния игры
                _F._cache.roleCache = {}
                
                -- Вызываем обработчик изменения состояния игры
                _F.OnGameStateChanged()
            end
        end
    end)
end

-- Функция создания переключателя
_F.CreateToggle = function(name, defaultValue, callback, parentFrame)
    local ToggleFrame = Instance.new("Frame")
    ToggleFrame.Name = name .. "Toggle"
    ToggleFrame.Size = UDim2.new(1, 0, 0, 40)
    ToggleFrame.Position = UDim2.new(0, 0, 0, 0)
    ToggleFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    ToggleFrame.BorderSizePixel = 0
    ToggleFrame.Parent = parentFrame
    
    local ToggleCorner = Instance.new("UICorner")
    ToggleCorner.CornerRadius = UDim.new(0, 8)
    ToggleCorner.Parent = ToggleFrame
    
    local ToggleLabel = Instance.new("TextLabel")
    ToggleLabel.Name = "ToggleLabel"
    ToggleLabel.Size = UDim2.new(0.7, 0, 1, 0)
    ToggleLabel.Position = UDim2.new(0, 15, 0, 0)
    ToggleLabel.BackgroundTransparency = 1
    ToggleLabel.Text = name
    ToggleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    ToggleLabel.TextSize = 14
    ToggleLabel.Font = Enum.Font.Gotham
    ToggleLabel.TextXAlignment = Enum.TextXAlignment.Left
    ToggleLabel.Parent = ToggleFrame
    
    local ToggleButton = Instance.new("TextButton")
    ToggleButton.Name = "ToggleButton"
    ToggleButton.Size = UDim2.new(0, 50, 0, 25)
    ToggleButton.Position = UDim2.new(1, -65, 0.5, -12.5)
    ToggleButton.BackgroundColor3 = defaultValue and Color3.fromRGB(0, 200, 0) or Color3.fromRGB(80, 80, 90)
    ToggleButton.BorderSizePixel = 0
    ToggleButton.Text = ""
    ToggleButton.Parent = ToggleFrame
    
    local ToggleCorner2 = Instance.new("UICorner")
    ToggleCorner2.CornerRadius = UDim.new(0, 12)
    ToggleCorner2.Parent = ToggleButton
    
    local ToggleDot = Instance.new("Frame")
    ToggleDot.Name = "ToggleDot"
    ToggleDot.Size = UDim2.new(0, 21, 0, 21)
    ToggleDot.Position = UDim2.new(0, defaultValue and 29 or 2, 0, 2)
    ToggleDot.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    ToggleDot.BorderSizePixel = 0
    ToggleDot.Parent = ToggleButton
    
    local ToggleCorner3 = Instance.new("UICorner")
    ToggleCorner3.CornerRadius = UDim.new(0, 10)
    ToggleCorner3.Parent = ToggleDot
    
    ToggleButton.MouseButton1Click:Connect(function()
        defaultValue = not defaultValue
        ToggleButton.BackgroundColor3 = defaultValue and Color3.fromRGB(0, 200, 0) or Color3.fromRGB(80, 80, 90)
        
        local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(ToggleDot, tweenInfo, {
            Position = UDim2.new(0, defaultValue and 29 or 2, 0, 2)
        })
        tween:Play()
        
        callback(defaultValue)
    end)
    
    return ToggleFrame
end

-- Функция создания слайдера
_F.CreateSlider = function(name, minValue, maxValue, defaultValue, callback, parentFrame)
    local SliderFrame = Instance.new("Frame")
    SliderFrame.Name = name .. "Slider"
    SliderFrame.Size = UDim2.new(1, 0, 0, 60)
    SliderFrame.Position = UDim2.new(0, 0, 0, 0)
    SliderFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    SliderFrame.BorderSizePixel = 0
    SliderFrame.Parent = parentFrame
    
    local SliderCorner = Instance.new("UICorner")
    SliderCorner.CornerRadius = UDim.new(0, 8)
    SliderCorner.Parent = SliderFrame
    
    local SliderLabel = Instance.new("TextLabel")
    SliderLabel.Name = "SliderLabel"
    SliderLabel.Size = UDim2.new(1, -30, 0, 20)
    SliderLabel.Position = UDim2.new(0, 15, 0, 5)
    SliderLabel.BackgroundTransparency = 1
    SliderLabel.Text = name .. ": " .. defaultValue
    SliderLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    SliderLabel.TextSize = 14
    SliderLabel.Font = Enum.Font.Gotham
    SliderLabel.TextXAlignment = Enum.TextXAlignment.Left
    SliderLabel.Parent = SliderFrame
    
    local SliderTrack = Instance.new("Frame")
    SliderTrack.Name = "SliderTrack"
    SliderTrack.Size = UDim2.new(1, -30, 0, 6)
    SliderTrack.Position = UDim2.new(0, 15, 0, 35)
    SliderTrack.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
    SliderTrack.BorderSizePixel = 0
    SliderTrack.Parent = SliderFrame
    
    local SliderTrackCorner = Instance.new("UICorner")
    SliderTrackCorner.CornerRadius = UDim.new(0, 3)
    SliderTrackCorner.Parent = SliderTrack
    
    local SliderFill = Instance.new("Frame")
    SliderFill.Name = "SliderFill"
    SliderFill.Size = UDim2.new((defaultValue - minValue) / (maxValue - minValue), 0, 1, 0)
    SliderFill.Position = UDim2.new(0, 0, 0, 0)
    SliderFill.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
    SliderFill.BorderSizePixel = 0
    SliderFill.Parent = SliderTrack
    
    local SliderFillCorner = Instance.new("UICorner")
    SliderFillCorner.CornerRadius = UDim.new(0, 3)
    SliderFillCorner.Parent = SliderFill
    
    local SliderButton = Instance.new("TextButton")
    SliderButton.Name = "SliderButton"
    SliderButton.Size = UDim2.new(0, 20, 0, 20)
    SliderButton.Position = UDim2.new((defaultValue - minValue) / (maxValue - minValue), -10, 0.5, -10)
    SliderButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    SliderButton.BorderSizePixel = 0
    SliderButton.Text = ""
    SliderButton.ZIndex = 2
    SliderButton.Parent = SliderTrack
    
    local SliderButtonCorner = Instance.new("UICorner")
    SliderButtonCorner.CornerRadius = UDim.new(0, 10)
    SliderButtonCorner.Parent = SliderButton
    
    local dragging = false
    
   local function updateSlider(input)
    if not dragging then return end
    
    local relativeX = math.clamp((input.Position.X - SliderTrack.AbsolutePosition.X) / SliderTrack.AbsoluteSize.X, 0, 1)
    local value = math.floor(minValue + (maxValue - minValue) * relativeX)
    
    if SliderFill and SliderButton then
        SliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
        SliderButton.Position = UDim2.new(relativeX, -10, 0.5, -10)
    end
    
    if SliderLabel then
        SliderLabel.Text = name .. ": " .. value
    end
    
    callback(value)
end
    
    SliderButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
        end
    end)
    
    SliderTrack.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            updateSlider(input)
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            updateSlider(input)
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    
    return SliderFrame
end

-- Функция создания кнопки
_F.CreateButton = function(name, callback, parentFrame)
    local ButtonFrame = Instance.new("Frame")
    ButtonFrame.Name = name .. "Button"
    ButtonFrame.Size = UDim2.new(1, 0, 0, 40)
    ButtonFrame.Position = UDim2.new(0, 0, 0, 0)
    ButtonFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    ButtonFrame.BorderSizePixel = 0
    ButtonFrame.Parent = parentFrame
    
    local ButtonCorner = Instance.new("UICorner")
    ButtonCorner.CornerRadius = UDim.new(0, 8)
    ButtonCorner.Parent = ButtonFrame
    
    local Button = Instance.new("TextButton")
    Button.Name = "Button"
    Button.Size = UDim2.new(1, -30, 1, -10)
    Button.Position = UDim2.new(0, 15, 0, 5)
    Button.BackgroundColor3 = Color3.fromRGB(0, 100, 255)
    Button.BorderSizePixel = 0
    Button.Text = name
    Button.TextColor3 = Color3.fromRGB(255, 255, 255)
    Button.TextSize = 14
    Button.Font = Enum.Font.GothamBold
    Button.Parent = ButtonFrame
    
    local ButtonCorner2 = Instance.new("UICorner")
    ButtonCorner2.CornerRadius = UDim.new(0, 6)
    ButtonCorner2.Parent = Button
    
    Button.MouseButton1Click:Connect(function()
        callback()
    end)
    
    return Button
end

-- HSV to RGB conversion
_F.HSVToRGB = function(h, s, v)
    h = h % 1
    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)
    
    if i == 0 then
        return Color3.new(v, t, p)
    elseif i == 1 then
        return Color3.new(q, v, p)
    elseif i == 2 then
        return Color3.new(p, v, t)
    elseif i == 3 then
        return Color3.new(p, q, v)
    elseif i == 4 then
        return Color3.new(t, p, v)
    else
        return Color3.new(v, p, q)
    end
end

-- RGB to HSV conversion
_F.RGBToHSV = function(color)
    local r, g, b = color.R, color.G, color.B
    local max = math.max(r, g, b)
    local min = math.min(r, g, b)
    local h, s, v
    
    v = max
    
    local d = max - min
    if max == 0 then
        s = 0
    else
        s = d / max
    end
    
    if max == min then
        h = 0
    else
        if max == r then
            h = (g - b) / d
            if g < b then
                h = h + 6
            end
        elseif max == g then
            h = (b - r) / d + 2
        elseif max == b then
            h = (r - g) / d + 4
        end
        h = h / 6
    end
    
    return h, s, v
end

-- Функция для RGB эффекта
_F.GetRainbowColor = function(time, speed)
    local hue = (tick() * speed) % 1
    return _F.HSVToRGB(hue, 1, 1)
end

-- Функция для SuperESP эффекта (переливание выбранного цвета)
_F.GetSuperESPColor = function(baseColor, time, speed)
    local h, s, v = _F.RGBToHSV(baseColor)
    local hue = (h + time * speed) % 1
    return _F.HSVToRGB(hue, s, v)
end

-- Функция создания полноценного HSV цветового пикера
_F.CreateHSVColorPicker = function(name, defaultColor, callback, parentFrame)
    local currentColor = defaultColor
    local currentH, currentS, currentV = _F.RGBToHSV(defaultColor)
    
    local ColorFrame = Instance.new("Frame")
    ColorFrame.Name = name .. "Color"
    ColorFrame.Size = UDim2.new(1, 0, 0, 40)
    ColorFrame.Position = UDim2.new(0, 0, 0, 0)
    ColorFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    ColorFrame.BorderSizePixel = 0
    ColorFrame.Parent = parentFrame
    
    local ColorCorner = Instance.new("UICorner")
    ColorCorner.CornerRadius = UDim.new(0, 8)
    ColorCorner.Parent = ColorFrame
    
    local ColorLabel = Instance.new("TextLabel")
    ColorLabel.Name = "ColorLabel"
    ColorLabel.Size = UDim2.new(0.6, 0, 1, 0)
    ColorLabel.Position = UDim2.new(0, 15, 0, 0)
    ColorLabel.BackgroundTransparency = 1
    ColorLabel.Text = name
    ColorLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    ColorLabel.TextSize = 14
    ColorLabel.Font = Enum.Font.Gotham
    ColorLabel.TextXAlignment = Enum.TextXAlignment.Left
    ColorLabel.Parent = ColorFrame
    
    local ColorButton = Instance.new("TextButton")
    ColorButton.Name = "ColorButton"
    ColorButton.Size = UDim2.new(0, 60, 0, 30)
    ColorButton.Position = UDim2.new(1, -75, 0.5, -15)
    ColorButton.BackgroundColor3 = defaultColor
    ColorButton.BorderSizePixel = 0
    ColorButton.Text = "Pick"
    ColorButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    ColorButton.TextSize = 12
    ColorButton.Font = Enum.Font.GothamBold
    ColorButton.Parent = ColorFrame
    
    local ColorCorner2 = Instance.new("UICorner")
    ColorCorner2.CornerRadius = UDim.new(0, 6)
    ColorCorner2.Parent = ColorButton
    
    -- Создание полноценного цветового пикера
    local ColorPickerFrame = Instance.new("Frame")
    ColorPickerFrame.Name = name .. "ColorPicker"
    ColorPickerFrame.Size = UDim2.new(0, 300, 0, 200)
    ColorPickerFrame.Position = UDim2.new(0.5, -150, 0.5, -100)
    ColorPickerFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    ColorPickerFrame.BorderSizePixel = 0
    ColorPickerFrame.Visible = false
    ColorPickerFrame.ZIndex = 100
    ColorPickerFrame.Parent = _F.ScreenGui
    
    local ColorPickerCorner = Instance.new("UICorner")
    ColorPickerCorner.CornerRadius = UDim.new(0, 12)
    ColorPickerCorner.Parent = ColorPickerFrame
    
    local ColorPickerStroke = Instance.new("UIStroke")
    ColorPickerStroke.Color = Color3.fromRGB(80, 80, 90)
    ColorPickerStroke.Thickness = 2
    ColorPickerStroke.Parent = ColorPickerFrame
    
    -- Палитра оттенков (Hue)
    local HuePicker = Instance.new("Frame")
    HuePicker.Name = "HuePicker"
    HuePicker.Size = UDim2.new(0, 260, 0, 20)
    HuePicker.Position = UDim2.new(0, 20, 0, 20)
    HuePicker.BackgroundColor3 = Color3.new(1, 1, 1)
    HuePicker.BorderSizePixel = 0
    HuePicker.Parent = ColorPickerFrame
    
    local HueGradient = Instance.new("UIGradient")
    HueGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
        ColorSequenceKeypoint.new(0.17, Color3.fromRGB(255, 255, 0)),
        ColorSequenceKeypoint.new(0.33, Color3.fromRGB(0, 255, 0)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 255)),
        ColorSequenceKeypoint.new(0.67, Color3.fromRGB(0, 0, 255)),
        ColorSequenceKeypoint.new(0.83, Color3.fromRGB(255, 0, 255)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0))
    })
    HueGradient.Parent = HuePicker
    
    local HueCorner = Instance.new("UICorner")
    HueCorner.CornerRadius = UDim.new(0, 4)
    HueCorner.Parent = HuePicker
    
    -- Ползунок Hue
    local HueSlider = Instance.new("Frame")
    HueSlider.Name = "HueSlider"
    HueSlider.Size = UDim2.new(0, 4, 0, 24)
    HueSlider.Position = UDim2.new(currentH, -2, 0, 18)
    HueSlider.BackgroundColor3 = Color3.new(1, 1, 1)
    HueSlider.BorderSizePixel = 0
    HueSlider.ZIndex = 101
    HueSlider.Parent = ColorPickerFrame
    
    local HueSliderCorner = Instance.new("UICorner")
    HueSliderCorner.CornerRadius = UDim.new(0, 2)
    HueSliderCorner.Parent = HueSlider
    
    -- Палитра насыщенности и яркости
    local SVPicker = Instance.new("Frame")
    SVPicker.Name = "SVPicker"
    SVPicker.Size = UDim2.new(0, 150, 0, 150)
    SVPicker.Position = UDim2.new(0, 20, 0, 50)
    SVPicker.BackgroundColor3 = _F.HSVToRGB(currentH, 1, 1)
    SVPicker.BorderSizePixel = 0
    SVPicker.Parent = ColorPickerFrame
    
    local SVGradient1 = Instance.new("UIGradient")
    SVGradient1.Rotation = 90
    SVGradient1.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
        ColorSequenceKeypoint.new(1, Color3.new(1, 1, 1))
    })
    SVGradient1.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 1)
    })
    SVGradient1.Parent = SVPicker
    
    local SVGradient2 = Instance.new("UIGradient")
    SVGradient2.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),
        ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0))
    })
    SVGradient2.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(1, 0)
    })
    SVGradient2.Parent = SVPicker
    
    local SVCorner = Instance.new("UICorner")
    SVCorner.CornerRadius = UDim.new(0, 4)
    SVCorner.Parent = SVPicker
    
    -- Ползунок SV
    local SVSlider = Instance.new("Frame")
    SVSlider.Name = "SVSlider"
    SVSlider.Size = UDim2.new(0, 8, 0, 8)
    SVSlider.Position = UDim2.new(currentS, -4, 1 - currentV, -4)
    SVSlider.BackgroundColor3 = Color3.new(1, 1, 1)
    SVSlider.BorderSizePixel = 0
    SVSlider.ZIndex = 101
    SVSlider.Parent = SVPicker
    
    local SVStroke = Instance.new("UIStroke")
    SVStroke.Color = Color3.new(0, 0, 0)
    SVStroke.Thickness = 1
    SVStroke.Parent = SVSlider
    
    local SVCorner2 = Instance.new("UICorner")
    SVCorner2.CornerRadius = UDim.new(0, 4)
    SVCorner2.Parent = SVSlider
    
    -- Предпросмотр цвета
    local PreviewFrame = Instance.new("Frame")
    PreviewFrame.Name = "PreviewFrame"
    PreviewFrame.Size = UDim2.new(0, 50, 0, 50)
    PreviewFrame.Position = UDim2.new(0, 190, 0, 50)
    PreviewFrame.BackgroundColor3 = currentColor
    PreviewFrame.BorderSizePixel = 0
    PreviewFrame.Parent = ColorPickerFrame
    
    local PreviewCorner = Instance.new("UICorner")
    PreviewCorner.CornerRadius = UDim.new(0, 6)
    PreviewCorner.Parent = PreviewFrame
    
    local PreviewStroke = Instance.new("UIStroke")
    PreviewStroke.Color = Color3.fromRGB(100, 100, 100)
    PreviewStroke.Thickness = 2
    PreviewStroke.Parent = PreviewFrame
    
    -- Кнопка применения
    local ApplyButton = Instance.new("TextButton")
    ApplyButton.Name = "ApplyButton"
    ApplyButton.Size = UDim2.new(0, 100, 0, 30)
    ApplyButton.Position = UDim2.new(0, 190, 0, 110)
    ApplyButton.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
    ApplyButton.BorderSizePixel = 0
    ApplyButton.Text = "APPLY"
    ApplyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    ApplyButton.TextSize = 14
    ApplyButton.Font = Enum.Font.GothamBold
    ApplyButton.Parent = ColorPickerFrame
    
    local ApplyCorner = Instance.new("UICorner")
    ApplyCorner.CornerRadius = UDim.new(0, 6)
    ApplyCorner.Parent = ApplyButton
    
    -- Функции обновления
    local function UpdateColor()
        currentColor = _F.HSVToRGB(currentH, currentS, currentV)
        PreviewFrame.BackgroundColor3 = currentColor
        SVPicker.BackgroundColor3 = _F.HSVToRGB(currentH, 1, 1)
    end
    
    local function UpdateHueSlider(position)
        local relativeX = math.clamp((position.X - HuePicker.AbsolutePosition.X) / HuePicker.AbsoluteSize.X, 0, 1)
        currentH = relativeX
        HueSlider.Position = UDim2.new(relativeX, -2, 0, 18)
        UpdateColor()
    end
    
    local function UpdateSVSlider(position)
        local relativeX = math.clamp((position.X - SVPicker.AbsolutePosition.X) / SVPicker.AbsoluteSize.X, 0, 1)
        local relativeY = math.clamp((position.Y - SVPicker.AbsolutePosition.Y) / SVPicker.AbsoluteSize.Y, 0, 1)
        currentS = relativeX
        currentV = 1 - relativeY
        SVSlider.Position = UDim2.new(relativeX, -4, 1 - currentV, -4)
        UpdateColor()
    end
    
    -- Обработчики событий
    local hueDragging = false
    local svDragging = false
    
    HuePicker.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            hueDragging = true
            UpdateHueSlider(input.Position)
        end
    end)
    
    SVPicker.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            svDragging = true
            UpdateSVSlider(input.Position)
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            if hueDragging then
                UpdateHueSlider(input.Position)
            elseif svDragging then
                UpdateSVSlider(input.Position)
            end
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            hueDragging = false
            svDragging = false
        end
    end)
    
    -- Кнопка применения
    ApplyButton.MouseButton1Click:Connect(function()
        callback(currentColor)
        ColorButton.BackgroundColor3 = currentColor
        ColorPickerFrame.Visible = false
    end)
    
    -- Открытие пикера
    ColorButton.MouseButton1Click:Connect(function()
        ColorPickerFrame.Visible = not ColorPickerFrame.Visible
    end)
    
    return ColorFrame
end

-- Упрощенный ESP Manager для игроков
_F.ESPManager = {
    Enabled = false,
    Players = {},
    Connections = {}
}

function _F.ESPManager:ClearAll()
    -- Очищаем ESP игроков
    for player, data in pairs(self.Players) do
        self:RemovePlayerESP(player)
    end
    
    -- Очищаем соединения
    for _, connection in pairs(self.Connections) do
        if connection then
            connection:Disconnect()
        end
    end
    
    self.Players = {}
    self.Connections = {}
end

function _F.ESPManager:IsValidPlayer(player)
    if not player then return false end
    if player == LocalPlayer then return false end
    if not player:IsDescendantOf(Players) then return false end
    
    -- Простая проверка: в лобби нет ESP
    if not _F.GameStarted then return false end
    
    return true
end

function _F.ESPManager:CreatePlayerESP(player)
    if not self:IsValidPlayer(player) then return end
    if self.Players[player] then return end
    
    local espData = {
        Folder = nil,
        Connections = {}
    }
    
    local function createESP(character)
        if not character or not character.Parent then return end
        
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 3)
        local humanoid = character:WaitForChild("Humanoid", 3)
        
        if not humanoidRootPart or not humanoid then return end
        
        -- Создаем ESP
        local espFolder = Instance.new("Folder")
        espFolder.Name = player.Name .. "_ESP"
        espFolder.Parent = _F.ScreenGui
        
        local highlight = Instance.new("Highlight")
        highlight.Name = "Highlight"
        highlight.Adornee = character
        highlight.FillColor = _F.SurvivorColor
        highlight.FillTransparency = 0.3
        highlight.OutlineColor = _F.SurvivorColor
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Parent = espFolder
        
        espData.Folder = espFolder
        self.Players[player] = espData
        
        -- Отслеживаем смерть
        espData.Connections.died = humanoid.Died:Connect(function()
            self:RemovePlayerESP(player)
        end)
    end
    
    -- Создаем ESP для текущего персонажа
    if player.Character then
        createESP(player.Character)
    end
    
    -- Отслеживаем смену персонажа
    espData.Connections.characterAdded = player.CharacterAdded:Connect(function(character)
        wait(2)
        if self:IsValidPlayer(player) then
            createESP(character)
        else
            self:RemovePlayerESP(player)
        end
    end)
    
    self.Players[player] = espData
end

function _F.ESPManager:RemovePlayerESP(player)
    if not self.Players[player] then return end
    
    local espData = self.Players[player]
    
    -- Удаляем соединения
    for _, connection in pairs(espData.Connections) do
        if connection then
            connection:Disconnect()
        end
    end
    
    -- Удаляем folder
    if espData.Folder then
        pcall(function()
            espData.Folder:Destroy()
        end)
    end
    
    self.Players[player] = nil
end

function _F.ESPManager:UpdateAll()
    if not self.Enabled then return end
    
    -- Очищаем невалидные ESP
    for player in pairs(self.Players) do
        if not self:IsValidPlayer(player) then
            self:RemovePlayerESP(player)
        end
    end
    
    -- Создаем ESP для валидных игроков
    for _, player in pairs(Players:GetPlayers()) do
        if self:IsValidPlayer(player) and not self.Players[player] then
            self:CreatePlayerESP(player)
        end
    end
end

function _F.ESPManager:SetEnabled(enabled)
    self.Enabled = enabled
    
    if enabled then
        self:UpdateAll()
        
        -- Отслеживаем новых игроков
        self.Connections.playerAdded = Players.PlayerAdded:Connect(function(player)
            wait(2)
            if self.Enabled then
                self:CreatePlayerESP(player)
            end
        end)
        
        -- Отслеживаем ушедших игроков
        self.Connections.playerRemoving = Players.PlayerRemoving:Connect(function(player)
            self:RemovePlayerESP(player)
        end)
        
    else
        self:ClearAll()
    end
end

-- Упрощенная и надежная система определения ролей
_F.GetPlayerRole = function(player)
    if not player or player == LocalPlayer then return "Unknown" end
    
    -- В лобби все считаются Survivor
    if not _F.GameStarted then
        return "Survivor"
    end
    
    -- Проверка команды
    if player.Team then
        local teamName = string.lower(player.Team.Name)
        if teamName == "spectator" or teamName == "spectators" then
            return "Spectator"
        elseif teamName == "killer" or teamName == "murderer" then
            return "Killer"
        else
            return "Survivor"
        end
    end
    
    -- Если команды нет, используем простую логику
    -- В активной игре если не Spectator, то Survivor
    return "Survivor"
end

-- Упрощенная проверка состояния игры
_F.CheckGameStarted = function()
    local activePlayers = 0
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local role = _F.GetPlayerRole(player)
            if role ~= "Spectator" then
                activePlayers = activePlayers + 1
            end
        end
    end
    
    -- Игра считается активной если есть хотя бы 2 активных игрока
    return activePlayers >= 2 and _F.MapLoaded
end

-- Система отслеживания изменений в игре
_F.GameStateManager = {
    LastMapState = false,
    LastGameState = false
}

function _F.GameStateManager:CheckForChanges()
    local currentMapState = _F.CheckMapLoaded()
    local currentGameState = _F.CheckGameStarted()
    
    -- Проверяем изменение состояния карты
    if currentMapState ~= self.LastMapState then
        self.LastMapState = currentMapState
        print("Map state changed: " .. tostring(currentMapState))
        
        if currentMapState then
            -- Карта загружена
            self:OnMapLoaded()
        else
            -- Карта выгружена (вернулись в лобби)
            self:OnMapUnloaded()
        end
    end
    
    -- Проверяем изменение состояния игры
    if currentGameState ~= self.LastGameState then
        self.LastGameState = currentGameState
        print("Game state changed: " .. tostring(currentGameState))
        
        if currentGameState then
            self:OnGameStarted()
        else
            self:OnGameEnded()
        end
    end
end

function _F.GameStateManager:OnMapLoaded()
    print("New map loaded - cleaning old ESP")
    _F.ESPManager:ClearAll()
end

function _F.GameStateManager:OnMapUnloaded()
    print("Map unloaded (back to lobby) - cleaning ESP")
    _F.ESPManager:ClearAll()
end

function _F.GameStateManager:OnGameStarted()
    print("Game started - initializing ESP")
    if _F.ESPEnabled then
        wait(3) -- Ждем полной загрузки
        _F.ESPManager:UpdateAll()
    end
end

function _F.GameStateManager:OnGameEnded()
    print("Game ended - cleaning ESP")
    _F.ESPManager:ClearAll()
end

-- Запуск отслеживания состояния игры
_F.StartGameStateMonitoring = function()
    while true do
        _F.GameStateManager:CheckForChanges()
        wait(5) -- Проверяем каждые 5 секунд
    end
end

-- Запускаем в отдельном потоке
coroutine.wrap(_F.StartGameStateMonitoring)()

_F.ToggleESP = function(enabled)
    _F.ESPEnabled = enabled
    _F.ESPManager:SetEnabled(enabled)
    print("ESP Players: " .. (enabled and "ENABLED" or "DISABLED"))
end

_F.ForceUpdateAllESP = function()
    print("Force updating ESP...")
    _F.ESPManager:UpdateAll()
end

_F.ClearAllESP = function()
    print("Clearing all ESP...")
    _F.ESPManager:ClearAll()
    _F.ObjectESPManager:ClearAll()
end

-- Вспомогательные функции для Object ESP Manager
_F.ObjectESPManager = {
    Enabled = false,
    Objects = {}
}

function _F.ObjectESPManager:ClearAll()
    for obj, folder in pairs(self.Objects) do
        if folder and folder.Parent then
            pcall(function()
                folder:Destroy()
            end)
        end
    end
    self.Objects = {}
end

function _F.ObjectESPManager:CreateObjectESP(obj, color, objectType)
    if not obj or not obj.Parent then return end
    if self.Objects[obj] then return end
    
    local espFolder = Instance.new("Folder")
    espFolder.Name = objectType .. "_ESP_" .. tostring(obj:GetFullName())
    espFolder.Parent = _F.ScreenGui
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "Highlight"
    highlight.Adornee = obj
    highlight.FillColor = color
    highlight.FillTransparency = 0.5
    highlight.OutlineColor = color
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = espFolder
    
    self.Objects[obj] = espFolder
    
    -- Отслеживаем удаление объекта
    spawn(function()
        while obj and obj.Parent do
            wait(2)
        end
        self:RemoveObjectESP(obj)
    end)
end

function _F.ObjectESPManager:RemoveObjectESP(obj)
    if self.Objects[obj] then
        pcall(function()
            self.Objects[obj]:Destroy()
        end)
        self.Objects[obj] = nil
    end
end

function _F.ObjectESPManager:FindAndCreateObjects(objectName, color, objectType)
    for _, obj in pairs(Workspace:GetDescendants()) do
        if string.lower(obj.Name) == string.lower(objectName) and (obj:IsA("Model") or obj:IsA("Part")) then
            self:CreateObjectESP(obj, color, objectType)
        end
    end
end

-- Функции для поиска генераторов и паллетов
_F.FindAndCreateGenerators = function()
    _F.ObjectESPManager:FindAndCreateObjects("Generator", _F.GeneratorColor, "Generator")
    _F.ObjectESPManager:FindAndCreateObjects("Generators", _F.GeneratorColor, "Generator")
end

_F.FindAndCreatePallets = function()
    _F.ObjectESPManager:FindAndCreateObjects("Pallet", _F.PalletColor, "Pallet")
    _F.ObjectESPManager:FindAndCreateObjects("PalletWrong", _F.PalletColor, "Pallet")
    _F.ObjectESPManager:FindAndCreateObjects("Pallets", _F.PalletColor, "Pallet")
end

_F.ToggleGeneratorESP = function(enabled)
    _F.GeneratorESPEnabled = enabled
    
    if enabled then
        print("Generator ESP: ENABLED")
        _F.FindAndCreateGenerators()
        
        -- Запускаем периодический поиск новых генераторов
        if not _F.AutoRefreshConnection then
            _F.AutoRefreshConnection = RunService.Heartbeat:Connect(function()
                if not _F.GeneratorESPEnabled then
                    _F.AutoRefreshConnection:Disconnect()
                    _F.AutoRefreshConnection = nil
                    return
                end
                
                -- Ищем новые генераторы каждые 5 секунд
                if tick() - (_F._lastGeneratorCheck or 0) > 5 then
                    _F._lastGeneratorCheck = tick()
                    _F.FindAndCreateGenerators()
                end
            end)
        end
        
    else
        print("Generator ESP: DISABLED")
        
        -- Удаляем только генераторы
        for obj, folder in pairs(_F.ObjectESPManager.Objects) do
            if folder and folder.Name:find("Generator") then
                _F.ObjectESPManager:RemoveObjectESP(obj)
            end
        end
        
        if _F.AutoRefreshConnection then
            _F.AutoRefreshConnection:Disconnect()
            _F.AutoRefreshConnection = nil
        end
    end
end

_F.TogglePalletESP = function(enabled)
    _F.PalletESPEnabled = enabled
    
    if enabled then
        print("Pallet ESP: ENABLED")
        _F.FindAndCreatePallets()
        
        -- Запускаем периодический поиск новых паллетов
        if not _F.AutoRefreshConnection then
            _F.AutoRefreshConnection = RunService.Heartbeat:Connect(function()
                if not _F.PalletESPEnabled then
                    _F.AutoRefreshConnection:Disconnect()
                    _F.AutoRefreshConnection = nil
                    return
                end
                
                -- Ищем новые паллеты каждые 5 секунд
                if tick() - (_F._lastPalletCheck or 0) > 5 then
                    _F._lastPalletCheck = tick()
                    _F.FindAndCreatePallets()
                end
            end)
        end
        
    else
        print("Pallet ESP: DISABLED")
        
        -- Удаляем только паллеты
        for obj, folder in pairs(_F.ObjectESPManager.Objects) do
            if folder and folder.Name:find("Pallet") then
                _F.ObjectESPManager:RemoveObjectESP(obj)
            end
        end
        
        if _F.AutoRefreshConnection then
            _F.AutoRefreshConnection:Disconnect()
            _F.AutoRefreshConnection = nil
        end
    end
end

-- ФУНКЦИЯ SUPER ESP (улучшенный визуал всех ESP)
_F.StartSuperESP = function()
    if _F.SuperESPConnection then
        _F.SuperESPConnection:Disconnect()
    end
    
    _F.SuperESPConnection = RunService.Heartbeat:Connect(function()
        if not _F.SuperESPEnabled or not _F.ESPEnabled then
            return
        end
        
        local time = tick()
        
        -- Обновляем ESP игроков
        for player, espFolder in pairs(_F.ESPFolders) do
            if player and espFolder and player.Character then
                local isKiller = _F.IsPlayerKiller(player)
                local baseColor = isKiller and _F.KillerColor or _F.SurvivorColor
                local superColor = _F.GetSuperESPColor(baseColor, time, _F.SuperESPSpeed)
                
                local highlight = espFolder:FindFirstChild("ESPHighlight")
                local billboard = espFolder:FindFirstChild("ESPBillboard")
                
                if highlight then
                    highlight.FillColor = superColor
                    highlight.OutlineColor = superColor
                end
                
                if billboard then
                    local nameLabel = billboard:FindFirstChild("ESPName")
                    if nameLabel then
                        nameLabel.TextColor3 = superColor
                    end
                end
            end
        end
        
        -- Обновляем ESP генераторов
        for generator, espFolder in pairs(_F.GeneratorESPItems) do
            if generator and espFolder then
                local superColor = _F.GetSuperESPColor(_F.GeneratorColor, time, _F.SuperESPSpeed)
                local highlight = espFolder:FindFirstChild("GeneratorHighlight")
                
                if highlight then
                    highlight.FillColor = superColor
                    highlight.OutlineColor = superColor
                end
            end
        end
        
        -- Обновляем ESP паллетов
        for pallet, espFolder in pairs(_F.PalletESPItems) do
            if pallet and espFolder then
                local superColor = _F.GetSuperESPColor(_F.PalletColor, time, _F.SuperESPSpeed)
                local highlight = espFolder:FindFirstChild("PalletHighlight")
                
                if highlight then
                    highlight.FillColor = superColor
                    highlight.OutlineColor = superColor
                end
            end
        end
    end)
end

_F.ToggleSuperESP = function(enabled)
    _F.SuperESPEnabled = enabled
    
    if enabled then
        _F.StartSuperESP()
        print("Super ESP: ENABLED")
    else
        if _F.SuperESPConnection then
            _F.SuperESPConnection:Disconnect()
            _F.SuperESPConnection = nil
        end
        -- Восстанавливаем обычные цвета
        _F.UpdateESP()
        _F.UpdateGeneratorESP()
        _F.UpdatePalletESP()
        print("Super ESP: DISABLED")
    end
end

_F.UpdateSuperESPSpeed = function(speed)
    _F.SuperESPSpeed = speed
    print("Super ESP Speed: " .. speed)
end

-- ИСПРАВЛЕННАЯ функция включения ESP
_F.ToggleESP = function(enabled)
    _F.ESPEnabled = enabled
    
    if enabled then
        print("ESP Players: ENABLED")
        
        -- Создаем ESP для всех существующих игроков
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and not _F.IsPlayerSpectator(player) then
                _F.CreateESP(player)
            end
        end
        
        -- Обработчик новых игроков
        if _F.PlayerAddedConnection then
            _F.PlayerAddedConnection:Disconnect()
        end
        
        _F.PlayerAddedConnection = Players.PlayerAdded:Connect(function(player)
            wait(3)
            if not _F.IsPlayerSpectator(player) then
                _F.CreateESP(player)
            end
        end)
        
        -- Обработчик удаления игроков
        Players.PlayerRemoving:Connect(function(player)
            _F.RemoveESP(player)
        end)
        
        -- Запускаем RGB ESP если включен
        if _F.RGBESPEnabled then
            _F.StartRGBESP()
        end
        
        -- Запускаем Super ESP если включен
        if _F.SuperESPEnabled then
            _F.StartSuperESP()
        end
        
    else
        print("ESP Players: DISABLED")
        
        -- Удаляем все ESP
        for player, _ in pairs(_F.ESPFolders) do
            _F.RemoveESP(player)
        end
        
        if _F.PlayerAddedConnection then
            _F.PlayerAddedConnection:Disconnect()
            _F.PlayerAddedConnection = nil
        end
        
        if _F.RGBESPConnection then
            _F.RGBESPConnection:Disconnect()
            _F.RGBESPConnection = nil
        end
        
        if _F.SuperESPConnection then
            _F.SuperESPConnection:Disconnect()
            _F.SuperESPConnection = nil
        end
    end
end

_F.ToggleGeneratorESP = function(enabled)
    _F.GeneratorESPEnabled = enabled
    
    if enabled then
        _F.FindAndCreateGenerators()
        print("ESP Generators: ENABLED")
        
        -- Запускаем Super ESP если включен
        if _F.SuperESPEnabled then
            _F.StartSuperESP()
        end
    else
        for generator, _ in pairs(_F.GeneratorESPItems) do
            _F.RemoveGeneratorESP(generator)
        end
        print("ESP Generators: DISABLED")
    end
end

_F.TogglePalletESP = function(enabled)
    _F.PalletESPEnabled = enabled
    
    if enabled then
        _F.FindAndCreatePallets()
        print("ESP Pallets: ENABLED")
        
        -- Запускаем Super ESP если включен
        if _F.SuperESPEnabled then
            _F.StartSuperESP()
        end
    else
        for pallet, _ in pairs(_F.PalletESPItems) do
            _F.RemovePalletESP(pallet)
        end
        print("ESP Pallets: DISABLED")
    end
end

-- ФУНКЦИИ ДЛЯ FEATURES И VISUAL

_F.ToggleWalkSpeed = function(enabled)
    _F.walkSpeedActive = enabled
    
    if enabled then
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = _F.walkSpeed
            end
        end
        print("WalkSpeed: ENABLED (" .. _F.walkSpeed .. ")")
    else
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = 16
            end
        end
        print("WalkSpeed: DISABLED")
    end
end

_F.UpdateWalkSpeedValue = function(value)
    _F.walkSpeed = value
    if _F.walkSpeedActive then
        _F.ToggleWalkSpeed(true)
    end
    print("WalkSpeed Value: " .. value)
end

-- Fly функция
_F.StartFly = function()
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    
    if not humanoidRootPart or not humanoid then return end
    
    _F.Flying = true
    
    _F.BodyVelocity = Instance.new("BodyVelocity")
    _F.BodyVelocity.Velocity = Vector3.new(0, 0, 0)
    _F.BodyVelocity.MaxForce = Vector3.new(40000, 40000, 40000)
    _F.BodyVelocity.Parent = humanoidRootPart
    
    _F.BodyGyro = Instance.new("BodyGyro")
    _F.BodyGyro.MaxTorque = Vector3.new(40000, 40000, 40000)
    _F.BodyGyro.P = 1000
    _F.BodyGyro.D = 50
    _F.BodyGyro.Parent = humanoidRootPart
    
    _F.FlyConnection = RunService.Heartbeat:Connect(function()
        if not _F.Flying or not character or not humanoidRootPart or not _F.BodyVelocity or not _F.BodyGyro then
            return
        end
        
        _F.BodyGyro.CFrame = Workspace.CurrentCamera.CFrame
        
        local velocity = Vector3.new(0, 0, 0)
        
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            velocity = velocity + (Workspace.CurrentCamera.CFrame.LookVector * _F.FlySpeedValue)
        end
        
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            velocity = velocity + (Workspace.CurrentCamera.CFrame.LookVector * -_F.FlySpeedValue)
        end
        
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            velocity = velocity + (Workspace.CurrentCamera.CFrame.RightVector * -_F.FlySpeedValue)
        end
        
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            velocity = velocity + (Workspace.CurrentCamera.CFrame.RightVector * _F.FlySpeedValue)
        end
        
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
            velocity = velocity + Vector3.new(0, _F.FlySpeedValue, 0)
        end
        
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            velocity = velocity + Vector3.new(0, -_F.FlySpeedValue, 0)
        end
        
        _F.BodyVelocity.Velocity = velocity
        humanoid.PlatformStand = true
    end)
end

_F.StopFly = function()
    _F.Flying = false
    
    if _F.FlyConnection then
        _F.FlyConnection:Disconnect()
    end
    
    local character = LocalPlayer.Character
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        
        if humanoid then
            humanoid.PlatformStand = false
        end
        
        if humanoidRootPart then
            if _F.BodyVelocity then
                _F.BodyVelocity:Destroy()
            end
            if _F.BodyGyro then
                _F.BodyGyro:Destroy()
            end
        end
    end
end

_F.ToggleFly = function(enabled)
    _F.FlyEnabled = enabled
    
    if enabled then
        _F.StartFly()
        print("Fly: ENABLED")
    else
        _F.StopFly()
        print("Fly: DISABLED")
    end
end

-- УЛУЧШЕННЫЙ NOCLIP ДЛЯ R6
_F.StartNoclip = function()
    local character = LocalPlayer.Character
    if not character then return end
    
    -- Останавливаем предыдущее соединение если есть
    if _F.NoclipConnection then
        _F.NoclipConnection:Disconnect()
        _F.NoclipConnection = nil
    end
    
    _F.NoclipConnection = RunService.Stepped:Connect(function()
        if not _F.NoclipEnabled or not character or not character.Parent then
            if _F.NoclipConnection then
                _F.NoclipConnection:Disconnect()
                _F.NoclipConnection = nil
            end
            return
        end
        
        -- Отключаем коллизию для всех BasePart в персонаже
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
        
        -- Специально для R6: основные части тела
        local r6Parts = {
            "Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"
        }
        
        for _, partName in ipairs(r6Parts) do
            local part = character:FindFirstChild(partName)
            if part and part:IsA("BasePart") then
                part.CanCollide = false
                part.Velocity = Vector3.new(0, 0, 0) -- Убираем физику
                part.RotVelocity = Vector3.new(0, 0, 0)
            end
        end
        
        -- Также отключаем коллизию у аксессуаров
        for _, accessory in pairs(character:GetChildren()) do
            if accessory:IsA("Accessory") then
                local handle = accessory:FindFirstChild("Handle")
                if handle and handle:IsA("BasePart") then
                    handle.CanCollide = false
                end
            end
        end
    end)
end

_F.StopNoclip = function()
    local character = LocalPlayer.Character
    if character then
        -- Восстанавливаем коллизию
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
    
    if _F.NoclipConnection then
        _F.NoclipConnection:Disconnect()
        _F.NoclipConnection = nil
    end
end

_F.ToggleNoclip = function(enabled)
    _F.NoclipEnabled = enabled
    
    -- Останавливаем отслеживание смены персонажа если было
    if _F.NoclipCharacterConnection then
        _F.NoclipCharacterConnection:Disconnect()
        _F.NoclipCharacterConnection = nil
    end
    
    if enabled then
        print("Noclip: ENABLED (R6 Compatible)")
        
        -- Запускаем сразу
        _F.StartNoclip()
        
        -- Отслеживаем смену персонажа
        _F.NoclipCharacterConnection = LocalPlayer.CharacterAdded:Connect(function(newCharacter)
            wait(1) -- Ждем загрузки персонажа
            if _F.NoclipEnabled then
                _F.StartNoclip()
            end
        end)
        
    else
        _F.StopNoclip()
        print("Noclip: DISABLED")
    end
end

-- Исправленная God Mode функция для Violence District
_F.ToggleGodMode = function(enabled)
    _F.GodModeEnabled = enabled
    
    if enabled then
        print("God Mode: ENABLED - Searching for health system...")
        
        if _F.GodModeConnection then
            _F.GodModeConnection:Disconnect()
        end
        
        _F.GodModeConnection = RunService.Heartbeat:Connect(function()
            if not _F.GodModeEnabled then
                if _F.GodModeConnection then
                    _F.GodModeConnection:Disconnect()
                    _F.GodModeConnection = nil
                end
                return
            end
            
            local character = LocalPlayer.Character
            if character then
                -- Поиск кастомной системы здоровья Violence District
                local foundHealth = false
                
                -- 1. Проверяем кастомные скрипты здоровья
                for _, script in pairs(character:GetDescendants()) do
                    if script:IsA("Script") or script:IsA("LocalScript") then
                        if string.find(string.lower(script.Name), "health") or 
                           string.find(string.lower(script.Name), "damage") or
                           string.find(string.lower(script.Name), "hit") then
                            -- Нашли скрипт связанный со здоровьем - пытаемся защитить
                            pcall(function()
                                script.Disabled = true
                            end)
                            foundHealth = true
                        end
                    end
                end
                
                -- 2. Проверяем кастомные значения здоровья
                for _, value in pairs(character:GetDescendants()) do
                    if value:IsA("NumberValue") or value:IsA("IntValue") then
                        local valueName = string.lower(value.Name)
                        if string.find(valueName, "health") or 
                           string.find(valueName, "hp") or
                           string.find(valueName, "damage") then
                            
                            -- Защищаем значение здоровья
                            pcall(function()
                                if value.Value < 100 then
                                    value.Value = 100
                                end
                            end)
                            foundHealth = true
                        end
                    end
                end
                
                -- 3. Защита от оглушения и захвата
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    -- Предотвращаем смерть
                    if humanoid.Health < 100 then
                        humanoid.Health = 100
                    end
                    
                    -- Предотвращаем оглушение
                    if humanoid.PlatformStand then
                        humanoid.PlatformStand = false
                    end
                    
                    if humanoid.Sit then
                        humanoid.Sit = false
                    end
                end
                
                -- 4. Защита от удаления персонажа (анти-килл)
                if character.Parent == nil then
                    -- Персонаж удален (убит) - пытаемся восстановить
                    pcall(function()
                        character.Parent = Workspace
                    end)
                end
                
                -- 5. Поиск и блокировка оружия убийцы
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and _F.IsPlayerKiller(player) then
                        local killerChar = player.Character
                        if killerChar then
                            -- Блокируем оружие убийцы
                            for _, tool in pairs(killerChar:GetChildren()) do
                                if tool:IsA("Tool") then
                                    pcall(function()
                                        tool:Destroy()
                                    end)
                                end
                            end
                            
                            -- Блокируем атаки
                            local killerHumanoid = killerChar:FindFirstChildOfClass("Humanoid")
                            if killerHumanoid then
                                pcall(function()
                                    killerHumanoid:ChangeState(Enum.HumanoidStateType.Running)
                                end)
                            end
                        end
                    end
                end
                
                if not foundHealth then
                    -- Если не нашли кастомную систему, используем стандартную защиту
                    if humanoid then
                        humanoid.MaxHealth = math.huge
                        humanoid.Health = math.huge
                    end
                end
            end
        end)
        
    else
        if _F.GodModeConnection then
            _F.GodModeConnection:Disconnect()
            _F.GodModeConnection = nil
        end
        
        -- Восстанавливаем нормальные настройки
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.MaxHealth = 100
                humanoid.Health = 100
            end
            
            -- Включаем скрипты обратно
            for _, script in pairs(character:GetDescendants()) do
                if script:IsA("Script") or script:IsA("LocalScript") then
                    pcall(function()
                        script.Disabled = false
                    end)
                end
            end
        end
        print("God Mode: DISABLED")
    end
end

-- Функция для поиска системы здоровья в игре
_F.FindHealthSystem = function()
    print("=== Searching for Health System ===")
    
    local character = LocalPlayer.Character
    if character then
        for _, obj in pairs(character:GetDescendants()) do
            local objName = string.lower(obj.Name)
            if string.find(objName, "health") or string.find(objName, "hp") or 
               string.find(objName, "damage") or string.find(objName, "hit") then
                print("Found: " .. obj:GetFullName() .. " (" .. obj.ClassName .. ")")
                
                if obj:IsA("NumberValue") or obj:IsA("IntValue") then
                    print("Value: " .. tostring(obj.Value))
                end
            end
        end
    end
    
    -- Также проверяем игрока
    for _, obj in pairs(LocalPlayer:GetDescendants()) do
        local objName = string.lower(obj.Name)
        if string.find(objName, "health") or string.find(objName, "hp") then
            print("Found in Player: " .. obj:GetFullName() .. " (" .. obj.ClassName .. ")")
        end
    end
    print("=== Health System Search Complete ===")
end

-- Time функция
_F.ToggleTime = function(enabled)
    _F.TimeEnabled = enabled
    
    if enabled then
        if not _F.TimeConnection then
            _F.TimeConnection = RunService.Heartbeat:Connect(function()
                if not _F.TimeEnabled then
                    if _F.TimeConnection then
                        _F.TimeConnection:Disconnect()
                        _F.TimeConnection = nil
                    end
                    return
                end
                Lighting.ClockTime = _F.TimeValue
            end)
        end
        print("Custom Time: ENABLED (" .. _F.TimeValue .. ")")
    else
        if _F.TimeConnection then
            _F.TimeConnection:Disconnect()
            _F.TimeConnection = nil
        end
        print("Custom Time: DISABLED")
    end
end

-- Map Color функция
_F.ToggleMapColor = function(enabled)
    _F.MapColorEnabled = enabled
    
    if enabled then
        if not _F.MapColorConnection then
            _F.MapColorConnection = RunService.Heartbeat:Connect(function()
                if not _F.MapColorEnabled then
                    if _F.MapColorConnection then
                        _F.MapColorConnection:Disconnect()
                        _F.MapColorConnection = nil
                    end
                    return
                end
                
                Lighting.Ambient = _F.MapColor
                Lighting.OutdoorAmbient = _F.MapColor
                Lighting.ColorShift_Bottom = _F.MapColor
                Lighting.ColorShift_Top = _F.MapColor
                
                if not Lighting:FindFirstChild("ColorCorrection") then
                    local colorCorrection = Instance.new("ColorCorrectionEffect")
                    colorCorrection.Name = "ColorCorrection"
                    colorCorrection.Saturation = _F.MapColorSaturation
                    colorCorrection.Parent = Lighting
                else
                    Lighting.ColorCorrection.Saturation = _F.MapColorSaturation
                end
            end)
        end
        print("Map Color: ENABLED")
    else
        if _F.MapColorConnection then
            _F.MapColorConnection:Disconnect()
            _F.MapColorConnection = nil
        end
        Lighting.Ambient = Color3.new(0.5, 0.5, 0.5)
        Lighting.OutdoorAmbient = Color3.new(0.5, 0.5, 0.5)
        Lighting.ColorShift_Bottom = Color3.new(0, 0, 0)
        Lighting.ColorShift_Top = Color3.new(0, 0, 0)
        
        if Lighting:FindFirstChild("ColorCorrection") then
            Lighting.ColorCorrection:Destroy()
        end
        print("Map Color: DISABLED")
    end
end

-- ИСПРАВЛЕННЫЕ ФУНКЦИИ ДЛЯ FEATURES

-- AntiStun функция
_F.ToggleAntiStun = function(enabled)
    _F.AntiStunEnabled = enabled
    
    if enabled then
        if _F.AntiStunConnection then
            _F.AntiStunConnection:Disconnect()
        end
        
        _F.AntiStunConnection = RunService.Heartbeat:Connect(function()
            if not _F.AntiStunEnabled then
                if _F.AntiStunConnection then
                    _F.AntiStunConnection:Disconnect()
                end
                return
            end
            
            local character = LocalPlayer.Character
            if character then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    -- Предотвращаем оглушение
                    if humanoid.PlatformStand then
                        humanoid.PlatformStand = false
                    end
                    
                    if humanoid.Sit then
                        humanoid.Sit = false
                    end
                    
                    -- Восстанавливаем управление
                    if humanoid:GetState() == Enum.HumanoidStateType.FallingDown or 
                       humanoid:GetState() == Enum.HumanoidStateType.Ragdoll then
                        humanoid:ChangeState(Enum.HumanoidStateType.Running)
                    end
                end
            end
        end)
        print("AntiStun: ENABLED")
    else
        if _F.AntiStunConnection then
            _F.AntiStunConnection:Disconnect()
            _F.AntiStunConnection = nil
        end
        print("AntiStun: DISABLED")
    end
end

-- СУПЕР БЫСТРАЯ AntiGrab функция
_F.ToggleAntiGrab = function(enabled)
    _F.AntiGrabEnabled = enabled
    
    if enabled then
        if _F.AntiGrabConnection then _F.AntiGrabConnection:Disconnect() end
        
        _F.AntiGrabConnection = RunService.Heartbeat:Connect(function()
            if not _F.AntiGrabEnabled then return end
            
            local character = LocalPlayer.Character
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                
                if rootPart and humanoid and humanoid.Health > 0 then
                    -- Мгновенное освобождение от захвата
                    if humanoid.PlatformStand then
                        humanoid.PlatformStand = false
                        rootPart.Velocity = Vector3.new(0, 50, 0)
                    end
                    
                    -- Сверхбыстрая проверка убийц
                    for i = 1, #Players:GetPlayers() do
                        local player = Players:GetPlayers()[i]
                        if player ~= LocalPlayer then
                            -- Быстрая проверка на убийцу без вызова функции
                            if player.Team and string.lower(player.Team.Name) == "killer" then
                                local killerChar = player.Character
                                if killerChar then
                                    local killerRoot = killerChar:FindFirstChild("HumanoidRootPart")
                                    if killerRoot then
                                        local dx = rootPart.Position.X - killerRoot.Position.X
                                        local dz = rootPart.Position.Z - killerRoot.Position.Z
                                        local distance = math.sqrt(dx*dx + dz*dz)
                                        
                                        if distance < 12 then
                                            -- Мгновенная телепортация
                                            local dirX, dirZ = dx/distance, dz/distance
                                            local newX = killerRoot.Position.X + dirX * 25
                                            local newZ = killerRoot.Position.Z + dirZ * 25
                                            
                                            rootPart.CFrame = CFrame.new(newX, rootPart.Position.Y + 3, newZ)
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end)
        print("AntiGrab: ENABLED - ULTRA FAST")
    else
        if _F.AntiGrabConnection then
            _F.AntiGrabConnection:Disconnect()
            _F.AntiGrabConnection = nil
        end
        print("AntiGrab: DISABLED")
    end
end

-- Max Escape Chance функция
_F.ToggleMaxEscapeChance = function(enabled)
    _F.MaxEscapeChanceEnabled = enabled
    
    if enabled then
        if _F.EscapeChanceConnection then
            _F.EscapeChanceConnection:Disconnect()
        end
        
        _F.EscapeChanceConnection = RunService.Heartbeat:Connect(function()
            if not _F.MaxEscapeChanceEnabled then
                if _F.EscapeChanceConnection then
                    _F.EscapeChanceConnection:Disconnect()
                end
                return
            end
            
            local character = LocalPlayer.Character
            if character then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                
                if humanoid and rootPart then
                    -- Автоматически вырываемся из захвата
                    if humanoid.PlatformStand or humanoid.Sit then
                        humanoid.PlatformStand = false
                        humanoid.Sit = false
                        rootPart.Velocity = rootPart.CFrame.LookVector * 50 + Vector3.new(0, 25, 0)
                    end
                    
                    -- Увеличиваем шанс побега при близости убийцы
                    for _, player in pairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer and _F.IsPlayerKiller(player) then
                            local killerChar = player.Character
                            if killerChar then
                                local killerRoot = killerChar:FindFirstChild("HumanoidRootPart")
                                if killerRoot and (rootPart.Position - killerRoot.Position).Magnitude < 8 then
                                    -- Автоматически убегаем
                                    local escapeDirection = (rootPart.Position - killerRoot.Position).Unit
                                    rootPart.Velocity = escapeDirection * 40 + Vector3.new(0, 15, 0)
                                end
                            end
                        end
                    end
                end
            end
        end)
        print("100% Escape Chance: ENABLED")
    else
        if _F.EscapeChanceConnection then
            _F.EscapeChanceConnection:Disconnect()
            _F.EscapeChanceConnection = nil
        end
        print("100% Escape Chance: DISABLED")
    end
end

-- Grab Killer функция
_F.ToggleGrabKiller = function(enabled)
    _F.GrabKillerEnabled = enabled
    
    if enabled then
        if _F.GrabKillerConnection then
            _F.GrabKillerConnection:Disconnect()
        end
        
        _F.GrabKillerConnection = RunService.Heartbeat:Connect(function()
            if not _F.GrabKillerEnabled then
                if _F.GrabKillerConnection then
                    _F.GrabKillerConnection:Disconnect()
                end
                return
            end
            
            local character = LocalPlayer.Character
            if character then
                local rootPart = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                
                if rootPart and humanoid then
                    local closestKiller = nil
                    local closestDistance = 15
                    
                    -- Ищем ближайшего убийцу
                    for _, player in pairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer and _F.IsPlayerKiller(player) and not _F.IsPlayerSpectator(player) then
                            local killerChar = player.Character
                            if killerChar then
                                local killerRoot = killerChar:FindFirstChild("HumanoidRootPart")
                                local killerHumanoid = killerChar:FindFirstChildOfClass("Humanoid")
                                
                                if killerRoot and killerHumanoid and killerHumanoid.Health > 0 then
                                    local distance = (rootPart.Position - killerRoot.Position).Magnitude
                                    if distance < closestDistance then
                                        closestDistance = distance
                                        closestKiller = player
                                    end
                                end
                            end
                        end
                    end
                    
                    -- Захватываем убийцу
                    if closestKiller then
                        local killerChar = closestKiller.Character
                        if killerChar then
                            local killerRoot = killerChar:FindFirstChild("HumanoidRootPart")
                            local killerHumanoid = killerChar:FindFirstChildOfClass("Humanoid")
                            
                            if killerRoot and killerHumanoid then
                                -- Оглушаем убийцу
                                killerHumanoid.PlatformStand = true
                                
                                -- Перемещаем убийцу перед собой
                                local offset = rootPart.CFrame.LookVector * 4 + Vector3.new(0, 1, 0)
                                killerRoot.CFrame = CFrame.new(rootPart.Position + offset)
                                
                                -- Останавливаем убийцу
                                killerRoot.Velocity = Vector3.new(0, 0, 0)
                                
                                -- Отключаем атаки убийцы
                                if killerHumanoid:FindFirstChild("Attack") then
                                    killerHumanoid.Attack:Destroy()
                                end
                            end
                        end
                    end
                end
            end
        end)
        print("Grab Killer: ENABLED")
    else
        if _F.GrabKillerConnection then
            _F.GrabKillerConnection:Disconnect()
            _F.GrabKillerConnection = nil
        end
        print("Grab Killer: DISABLED")
    end
end

-- Rapid Fire функция
_F.ToggleRapidFire = function(enabled)
    _F.RapidFireEnabled = enabled
    
    if enabled then
        if _F.RapidFireConnection then
            _F.RapidFireConnection:Disconnect()
        end
        
        _F.RapidFireConnection = RunService.Heartbeat:Connect(function()
            if not _F.RapidFireEnabled then
                if _F.RapidFireConnection then
                    _F.RapidFireConnection:Disconnect()
                end
                return
            end
            
            local character = LocalPlayer.Character
            if character then
                -- Ищем оружие в инвентаре
                local backpack = LocalPlayer:FindFirstChild("Backpack")
                local tool = nil
                
                -- Проверяем инструмент в руках
                for _, item in pairs(character:GetChildren()) do
                    if item:IsA("Tool") and (string.find(string.lower(item.Name), "twist") or 
                       string.find(string.lower(item.Name), "fate") or 
                       string.find(string.lower(item.Name), "pistol") or
                       string.find(string.lower(item.Name), "gun")) then
                        tool = item
                        break
                    end
                end
                
                -- Проверяем инструмент в рюкзаке
                if not tool and backpack then
                    for _, item in pairs(backpack:GetChildren()) do
                        if item:IsA("Tool") and (string.find(string.lower(item.Name), "twist") or 
                           string.find(string.lower(item.Name), "fate") or 
                           string.find(string.lower(item.Name), "pistol") or
                           string.find(string.lower(item.Name), "gun")) then
                            tool = item
                            break
                        end
                    end
                end
                
                -- Ускоряем стрельбу
                if tool then
                    -- Убираем задержки
                    for _, value in pairs(tool:GetDescendants()) do
                        if value:IsA("NumberValue") and (value.Name == "Cooldown" or value.Name == "Delay" or value.Name == "FireRate") then
                            value.Value = 0
                        end
                    end
                    
                    -- Автоматическая стрельба при зажатой ЛКМ
                    if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
                        if tool.Parent == character then
                            tool:Activate()
                        end
                    end
                end
            end
        end)
        print("Rapid Fire: ENABLED")
    else
        if _F.RapidFireConnection then
            _F.RapidFireConnection:Disconnect()
            _F.RapidFireConnection = nil
        end
        print("Rapid Fire: DISABLED")
    end
end

-- Disable Twist Animations функция
_F.ToggleTwistAnimations = function(enabled)
    _F.DisableTwistAnimationsEnabled = enabled
    
    if enabled then
        if _F.TwistAnimationsConnection then
            _F.TwistAnimationsConnection:Disconnect()
        end
        
        _F.TwistAnimationsConnection = RunService.Heartbeat:Connect(function()
            if not _F.DisableTwistAnimationsEnabled then
                if _F.TwistAnimationsConnection then
                    _F.TwistAnimationsConnection:Disconnect()
                end
                return
            end
            
            local character = LocalPlayer.Character
            if character then
                -- Ищем оружие Twist of Fate
                local backpack = LocalPlayer:FindFirstChild("Backpack")
                local tool = nil
                
                for _, item in pairs(character:GetChildren()) do
                    if item:IsA("Tool") and (string.find(string.lower(item.Name), "twist") or 
                       string.find(string.lower(item.Name), "fate")) then
                        tool = item
                        break
                    end
                end
                
                if not tool and backpack then
                    for _, item in pairs(backpack:GetChildren()) do
                        if item:IsA("Tool") and (string.find(string.lower(item.Name), "twist") or 
                           string.find(string.lower(item.Name), "fate")) then
                            tool = item
                            break
                        end
                    end
                end
                
                -- Отключаем анимации и эффекты
                if tool then
                    for _, animationTrack in pairs(tool:GetDescendants()) do
                        if animationTrack:IsA("AnimationTrack") then
                            animationTrack:Stop()
                        end
                    end
                    
                    for _, sound in pairs(tool:GetDescendants()) do
                        if sound:IsA("Sound") then
                            sound:Stop()
                        end
                    end
                    
                    for _, particle in pairs(tool:GetDescendants()) do
                        if particle:IsA("ParticleEmitter") then
                            particle.Enabled = false
                        end
                    end
                end
            end
        end)
        print("Disable Twist Animations: ENABLED")
    else
        if _F.TwistAnimationsConnection then
            _F.TwistAnimationsConnection:Disconnect()
            _F.TwistAnimationsConnection = nil
        end
        print("Disable Twist Animations: DISABLED")
    end
end

-- No Fog функция
_F.ToggleNoFog = function(enabled)
    _F.NoFogEnabled = enabled
    
    if enabled then
        if _F.NoFogConnection then
            _F.NoFogConnection:Disconnect()
        end
        
        _F.NoFogConnection = RunService.Heartbeat:Connect(function()
            if not _F.NoFogEnabled then
                if _F.NoFogConnection then
                    _F.NoFogConnection:Disconnect()
                end
                return
            end
            
            -- Убираем туман
            if Lighting:FindFirstChild("FogEnd") then
                Lighting.FogEnd = 1000000
            end
            if Lighting:FindFirstChild("FogStart") then
                Lighting.FogStart = 100000
            end
            if Lighting:FindFirstChild("FogColor") then
                Lighting.FogColor = Color3.new(1, 1, 1)
            end
        end)
        print("No Fog: ENABLED")
    else
        if _F.NoFogConnection then
            _F.NoFogConnection:Disconnect()
            _F.NoFogConnection = nil
        end
        -- Восстанавливаем стандартные настройки тумана
        if Lighting:FindFirstChild("FogEnd") then
            Lighting.FogEnd = 1000
        end
        if Lighting:FindFirstChild("FogStart") then
            Lighting.FogStart = 0
        end
        print("No Fog: DISABLED")
    end
end

-- Функция телепортации к игроку
_F.TeleportToPlayer = function(player)
    if not player or player == LocalPlayer then 
        print("Cannot teleport to yourself")
        return 
    end
    
    local character = LocalPlayer.Character
    local targetCharacter = player.Character
    
    if not character or not targetCharacter then
        print("Character not found")
        return
    end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
    
    if not humanoidRootPart or not targetRootPart then
        print("HumanoidRootPart not found")
        return
    end
    
    -- Телепортируемся к игроку
    humanoidRootPart.CFrame = CFrame.new(targetRootPart.Position + Vector3.new(3, 0, 3))
    print("Teleported to: " .. player.Name)
end

-- Функция обновления списка игроков
_F.UpdateTeleportPlayersList = function()
    if not _F.TeleportPlayersFrame then return end
    
    -- Очищаем старый список
    for _, child in ipairs(_F.TeleportPlayersFrame:GetChildren()) do
        child:Destroy()
    end
    
    local playerCount = 0
    
    -- Добавляем игроков в список
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and not _F.IsPlayerSpectator(player) then
            playerCount = playerCount + 1
            
            local isKiller = _F.IsPlayerKiller(player)
            local playerButton = Instance.new("TextButton")
            playerButton.Name = player.Name
            playerButton.Size = UDim2.new(1, -10, 0, 35)
            playerButton.Position = UDim2.new(0, 5, 0, (playerCount - 1) * 40)
            playerButton.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
            playerButton.BorderSizePixel = 0
            playerButton.Text = player.Name .. " (" .. (isKiller and "KILLER" or "SURVIVOR") .. ")"
            playerButton.TextColor3 = isKiller and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(0, 255, 0)
            playerButton.TextSize = 12
            playerButton.Font = Enum.Font.GothamBold
            playerButton.Parent = _F.TeleportPlayersFrame
            
            local buttonCorner = Instance.new("UICorner")
            buttonCorner.CornerRadius = UDim.new(0, 6)
            buttonCorner.Parent = playerButton
            
            playerButton.MouseButton1Click:Connect(function()
                _F.TeleportToPlayer(player)
                if _F.TeleportFrame then
                    _F.TeleportFrame.Visible = false
                end
            end)
        end
    end
    
    -- Обновляем размер контента
    _F.TeleportPlayersFrame.CanvasSize = UDim2.new(0, 0, 0, math.max(50, playerCount * 40))
    
    -- Если игроков нет
    if playerCount == 0 then
        local noPlayersLabel = Instance.new("TextLabel")
        noPlayersLabel.Size = UDim2.new(1, -10, 0, 50)
        noPlayersLabel.Position = UDim2.new(0, 5, 0, 0)
        noPlayersLabel.BackgroundTransparency = 1
        noPlayersLabel.Text = "No other players found"
        noPlayersLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        noPlayersLabel.TextSize = 14
        noPlayersLabel.Font = Enum.Font.Gotham
        noPlayersLabel.Parent = _F.TeleportPlayersFrame
    end
end

-- Функция создания меню телепортации
_F.CreateTeleportMenu = function()
    -- Основной фрейм
    _F.TeleportFrame = Instance.new("Frame")
    _F.TeleportFrame.Name = "TeleportFrame"
    _F.TeleportFrame.Size = UDim2.new(0, 350, 0, 450)
    _F.TeleportFrame.Position = UDim2.new(0.5, -175, 0.5, -225)
    _F.TeleportFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    _F.TeleportFrame.BorderSizePixel = 0
    _F.TeleportFrame.Visible = false
    _F.TeleportFrame.ZIndex = 100
    _F.TeleportFrame.Parent = _F.ScreenGui
    
    local teleportCorner = Instance.new("UICorner")
    teleportCorner.CornerRadius = UDim.new(0, 12)
    teleportCorner.Parent = _F.TeleportFrame
    
    local teleportStroke = Instance.new("UIStroke")
    teleportStroke.Color = Color3.fromRGB(80, 80, 90)
    teleportStroke.Thickness = 2
    teleportStroke.Parent = _F.TeleportFrame
    
    -- Заголовок для перетаскивания
    local titleFrame = Instance.new("Frame")
    titleFrame.Name = "TitleFrame"
    titleFrame.Size = UDim2.new(1, 0, 0, 40)
    titleFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    titleFrame.BorderSizePixel = 0
    titleFrame.Parent = _F.TeleportFrame
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 12)
    titleCorner.Parent = titleFrame
    
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "TitleLabel"
    titleLabel.Size = UDim2.new(1, 0, 1, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "TELEPORT TO PLAYER"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextSize = 16
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.Parent = titleFrame
    
    -- Список игроков
    _F.TeleportPlayersFrame = Instance.new("ScrollingFrame")
    _F.TeleportPlayersFrame.Name = "TeleportPlayersFrame"
    _F.TeleportPlayersFrame.Size = UDim2.new(1, -20, 1, -120)
    _F.TeleportPlayersFrame.Position = UDim2.new(0, 10, 0, 50)
    _F.TeleportPlayersFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    _F.TeleportPlayersFrame.BorderSizePixel = 0
    _F.TeleportPlayersFrame.ScrollBarThickness = 6
    _F.TeleportPlayersFrame.ScrollBarImageColor3 = Color3.fromRGB(80, 80, 90)
    _F.TeleportPlayersFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    _F.TeleportPlayersFrame.Parent = _F.TeleportFrame
    
    local playersCorner = Instance.new("UICorner")
    playersCorner.CornerRadius = UDim.new(0, 8)
    playersCorner.Parent = _F.TeleportPlayersFrame
    
    -- Кнопки
    local refreshButton = Instance.new("TextButton")
    refreshButton.Name = "RefreshButton"
    refreshButton.Size = UDim2.new(0, 120, 0, 35)
    refreshButton.Position = UDim2.new(0, 20, 1, -60)
    refreshButton.BackgroundColor3 = Color3.fromRGB(0, 100, 255)
    refreshButton.BorderSizePixel = 0
    refreshButton.Text = "REFRESH"
    refreshButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    refreshButton.TextSize = 14
    refreshButton.Font = Enum.Font.GothamBold
    refreshButton.Parent = _F.TeleportFrame
    
    local refreshCorner = Instance.new("UICorner")
    refreshCorner.CornerRadius = UDim.new(0, 8)
    refreshCorner.Parent = refreshButton
    
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 120, 0, 35)
    closeButton.Position = UDim2.new(1, -140, 1, -60)
    closeButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
    closeButton.BorderSizePixel = 0
    closeButton.Text = "CLOSE"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.TextSize = 14
    closeButton.Font = Enum.Font.GothamBold
    closeButton.Parent = _F.TeleportFrame
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 8)
    closeCorner.Parent = closeButton
    
    -- Система перетаскивания
    local dragging = false
    local dragInput, dragStart, startPos
    
    local function update(input)
        if dragging then
            local delta = input.Position - dragStart
            _F.TeleportFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end
    
    titleFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = _F.TeleportFrame.Position
        end
    end)
    
    titleFrame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            update(input)
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    
    -- Обработчики кнопок
    refreshButton.MouseButton1Click:Connect(function()
        _F.UpdateTeleportPlayersList()
    end)
    
    closeButton.MouseButton1Click:Connect(function()
        _F.TeleportFrame.Visible = false
    end)
end

-- Функция открытия меню телепортации
_F.OpenTeleportMenu = function()
    if not _F.TeleportFrame then
        _F.CreateTeleportMenu()
    end
    
    _F.TeleportFrame.Visible = true
    _F.UpdateTeleportPlayersList()
end

-- Third Person View функция (только для убийцы)
_F.StartThirdPerson = function()
    if not _F.ThirdPersonEnabled then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    -- Проверяем, является ли игрок убийцей
    if not _F.IsPlayerKiller(LocalPlayer) then
        print("Third Person: Available only for Killer")
        return
    end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    -- Сохраняем оригинальный тип камеры
    if not _F.OriginalCameraType then
        _F.OriginalCameraType = Workspace.CurrentCamera.CameraType
    end
    
    -- Меняем на вид от третьего лица
    Workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
    Workspace.CurrentCamera.CameraSubject = humanoidRootPart
    
    print("Third Person View: ENABLED")
end

_F.StopThirdPerson = function()
    -- Восстанавливаем оригинальный тип камеры
    if _F.OriginalCameraType then
        Workspace.CurrentCamera.CameraType = _F.OriginalCameraType
        _F.OriginalCameraType = nil
    end
    
    -- Восстанавливаем слежение за персонажем
    local character = LocalPlayer.Character
    if character then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            Workspace.CurrentCamera.CameraSubject = humanoid
        end
    end
    
    print("Third Person View: DISABLED")
end

_F.UpdateThirdPersonView = function()
    if not _F.ThirdPersonEnabled then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    -- Позиция камеры за спиной персонажа
    local offset = Vector3.new(0, 2, 8) -- Смещение камеры
    local lookVector = humanoidRootPart.CFrame.LookVector
    
    -- Вычисляем позицию камеры
    local cameraPosition = humanoidRootPart.Position - lookVector * offset.Z + Vector3.new(0, offset.Y, 0)
    
    -- Направляем камеру на персонажа
    Workspace.CurrentCamera.CFrame = CFrame.lookAt(cameraPosition, humanoidRootPart.Position + Vector3.new(0, 2, 0))
end

_F.ToggleThirdPerson = function(enabled)
    _F.ThirdPersonEnabled = enabled
    
    -- Проверяем, является ли игрок убийцей
    if enabled and not _F.IsPlayerKiller(LocalPlayer) then
        print("Third Person: You are not the Killer!")
        _F.ThirdPersonEnabled = false
        return
    end
    
    if enabled then
        -- Запускаем вид от третьего лица
        _F.StartThirdPerson()
        
        -- Создаем соединение для обновления камеры
        if _F.ThirdPersonConnection then
            _F.ThirdPersonConnection:Disconnect()
        end
        
        _F.ThirdPersonConnection = RunService.RenderStepped:Connect(function()
            if not _F.ThirdPersonEnabled then
                _F.ThirdPersonConnection:Disconnect()
                _F.StopThirdPerson()
                return
            end
            
            -- Проверяем, все еще убийца ли игрок
            if not _F.IsPlayerKiller(LocalPlayer) then
                print("Third Person: You are no longer the Killer!")
                _F.ToggleThirdPerson(false)
                return
            end
            
            _F.UpdateThirdPersonView()
        end)
        
        -- Отслеживаем смену персонажа
        LocalPlayer.CharacterAdded:Connect(function()
            wait(1)
            if _F.ThirdPersonEnabled and _F.IsPlayerKiller(LocalPlayer) then
                _F.StartThirdPerson()
            end
        end)
        
    else
        -- Отключаем вид от третьего лица
        if _F.ThirdPersonConnection then
            _F.ThirdPersonConnection:Disconnect()
            _F.ThirdPersonConnection = nil
        end
        _F.StopThirdPerson()
    end
end

-- Функция для проверки обновления роли
_F.CheckKillerRole = function()
    if _F.ThirdPersonEnabled and not _F.IsPlayerKiller(LocalPlayer) then
        print("Auto-disabling Third Person: No longer Killer")
        _F.ToggleThirdPerson(false)
    end
end

-- Автопроверка роли каждые 3 секунды
coroutine.wrap(function()
    while true do
        wait(3)
        _F.CheckKillerRole()
    end
end)()

-- СОЗДАНИЕ ЭЛЕМЕНТОВ МЕНЮ

-- ESP SETTINGS
_F.CreateToggle("ESP Players", false, _F.ToggleESP, _F.ESPSettingsFrame)
_F.CreateToggle("ESP Generators", false, _F.ToggleGeneratorESP, _F.ESPSettingsFrame)
_F.CreateToggle("ESP Pallets", false, _F.TogglePalletESP, _F.ESPSettingsFrame)
_F.CreateToggle("RGB ESP Killer", false, _F.ToggleRGBESP, _F.ESPSettingsFrame)
_F.CreateSlider("RGB ESP Speed", 0.1, 5, 1, _F.UpdateRGBESPSpeed, _F.ESPSettingsFrame)
_F.CreateToggle("Super ESP", false, _F.ToggleSuperESP, _F.ESPSettingsFrame)
_F.CreateSlider("Super ESP Speed", 0.1, 5, 1, _F.UpdateSuperESPSpeed, _F.ESPSettingsFrame)

-- ESP COLORS
_F.CreateHSVColorPicker("Killer Color", _F.KillerColor, function(color)
    _F.KillerColor = color
    if _F.ESPEnabled then 
        wait(0.1)
        _F.UpdateESP() 
    end
end, _F.ESPColorsFrame)

_F.CreateHSVColorPicker("Survivor Color", _F.SurvivorColor, function(color)
    _F.SurvivorColor = color
    if _F.ESPEnabled then 
        wait(0.1)
        _F.UpdateESP() 
    end
end, _F.ESPColorsFrame)

_F.CreateHSVColorPicker("Generator Color", _F.GeneratorColor, function(color)
    _F.GeneratorColor = color
    if _F.GeneratorESPEnabled then 
        wait(0.1)
        _F.UpdateGeneratorESP() 
    end
end, _F.ESPColorsFrame)

_F.CreateHSVColorPicker("Pallet Color", _F.PalletColor, function(color)
    _F.PalletColor = color
    if _F.PalletESPEnabled then 
        wait(0.1)
        _F.UpdatePalletESP() 
    end
end, _F.ESPColorsFrame)

-- GAME FEATURES

-- Walk Speed функция
_F.walkSpeedActive = false
_F.walkSpeed = 16
_F.walkSpeedConnection = nil

_F.ToggleWalkSpeed = function(enabled)
    _F.walkSpeedActive = enabled
    
    if _F.walkSpeedConnection then
        _F.walkSpeedConnection:Disconnect()
        _F.walkSpeedConnection = nil
    end
    
    if enabled then
        print("WalkSpeed: ENABLED")
        
        local function applyWalkSpeed()
            local character = LocalPlayer.Character
            if character then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid.WalkSpeed = _F.walkSpeed
                    print("WalkSpeed set to: " .. _F.walkSpeed)
                    
                    -- Мониторинг изменений WalkSpeed (для обхода античита)
                    _F.walkSpeedConnection = humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
                        if _F.walkSpeedActive and humanoid.WalkSpeed ~= _F.walkSpeed then
                            humanoid.WalkSpeed = _F.walkSpeed
                            print("WalkSpeed reset by server, reapplying: " .. _F.walkSpeed)
                        end
                    end)
                else
                    warn("Humanoid not found for WalkSpeed")
                end
            end
        end
        
        
        applyWalkSpeed()
        
       
        LocalPlayer.CharacterAdded:Connect(function(character)
            wait(0.5) -- Ждем загрузки персонажа
            if _F.walkSpeedActive then
                applyWalkSpeed()
            end
        end)
        
    else
        print("WalkSpeed: DISABLED")
        
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = 16
                print("WalkSpeed reset to default: 16")
            end
        end
    end
end

_F.UpdateWalkSpeedValue = function(value)
    _F.walkSpeed = value
    print("WalkSpeed value updated to: " .. value)
    
    if _F.walkSpeedActive then
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = _F.walkSpeed
                print("WalkSpeed immediately updated to: " .. _F.walkSpeed)
            end
        end
    end
end

_F.ToggleJumpPower = function(enabled)
    _F.JumpPowerEnabled = enabled
    
    if _F.JumpPowerConnection then
        _F.JumpPowerConnection:Disconnect()
        _F.JumpPowerConnection = nil
    end
    
    if enabled then
        print("Enabling JumpPower...")
        _F.UpdateJumpPower()
        
        _F.JumpPowerConnection = LocalPlayer.CharacterAdded:Connect(function(character)
            print("New character detected, applying JumpPower...")
            
            for i = 1, 3 do
                wait(1)
                _F.UpdateJumpPower()
            end
            
            local humanoid = character:WaitForChild("Humanoid", 5)
            if humanoid then
                humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
                    if _F.JumpPowerEnabled and humanoid.JumpPower ~= _F.JumpPowerValue then
                        humanoid.JumpPower = _F.JumpPowerValue
                        print("JumpPower corrected: " .. _F.JumpPowerValue)
                    end
                end)
                
                while _F.JumpPowerEnabled and character and humanoid do
                    wait(2)
                    if humanoid.JumpPower ~= _F.JumpPowerValue then
                        humanoid.JumpPower = _F.JumpPowerValue
                        print("JumpPower force updated: " .. _F.JumpPowerValue)
                    end
                end
            end
        end)
        
        coroutine.wrap(function()
            while _F.JumpPowerEnabled do
                wait(3)
                _F.UpdateJumpPower()
            end
        end)()
        
    else
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.JumpPower = 50
            end
        end
        print("JumpPower: DISABLED")
    end
end

_F.UpdateJumpPowerValue = function(value)
    _F.JumpPowerValue = value
    print("JumpPower value changed to: " .. value)
    if _F.JumpPowerEnabled then
        _F.UpdateJumpPower()
    end
end


_F.StartRotatePerson = function()
    if _F.RotateConnection then
        _F.RotateConnection:Disconnect()
    end
    
    _F.RotateConnection = RunService.Heartbeat:Connect(function()
        if not _F.RotatePersonEnabled then
            if _F.RotateConnection then
                _F.RotateConnection:Disconnect()
                _F.RotateConnection = nil
            end
            return
        end
        
        local character = LocalPlayer.Character
        if character then
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                -- Вращаем персонажа
                local currentCFrame = humanoidRootPart.CFrame
                local rotation = CFrame.Angles(0, math.rad(_F.RotateSpeed) * 0.1, 0)
                humanoidRootPart.CFrame = currentCFrame * rotation
            end
        end
    end)
end

_F.StopRotatePerson = function()
    if _F.RotateConnection then
        _F.RotateConnection:Disconnect()
        _F.RotateConnection = nil
    end
end

_F.ToggleRotatePerson = function(enabled)
    _F.RotatePersonEnabled = enabled
    
    if enabled then
        _F.StartRotatePerson()
        print("Rotate Person: ENABLED (Speed: " .. _F.RotateSpeed .. ")")
    else
        _F.StopRotatePerson()
        print("Rotate Person: DISABLED")
    end
end

_F.UpdateRotateSpeed = function(value)
    _F.RotateSpeed = value
    print("Rotate Speed: " .. value)
    
    if _F.RotatePersonEnabled then
        _F.StopRotatePerson()
        _F.StartRotatePerson()
    end
end

coroutine.wrap(function()
    local lastState = false
    
    while true do
        wait(5)
        
        
        local otherPlayers = false
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                otherPlayers = true
                break
            end
        end
        
        local currentState = otherPlayers and _F.MapLoaded
        
        if currentState ~= lastState then
            lastState = currentState
            _F.GameStarted = currentState
            
            if currentState then
                print("Game started - initializing systems")
            else
                print("Game ended - cleaning systems")
                _F.ESPManager:ClearAll()
                _F.ObjectESPManager:ClearAll()
            end
        end
    end
end)()

_F.FindAimbotTarget = function()
    if not _F.AimbotEnabled then return nil end
    
    local camera = Workspace.CurrentCamera
    local mousePos = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2) -- Центр экрана
    local closestTarget = nil
    local closestDistance = _F.AimbotFOV
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            -- Проверка команды
            if _F.AimbotTeamCheck and _F.IsPlayerKiller(player) then
                local character = player.Character
                if character and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0 then
                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        
                        if _F.AimbotVisibleCheck then
                            local raycastParams = RaycastParams.new()
                            raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, character}
                            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                            
                            local raycastResult = Workspace:Raycast(
                                camera.CFrame.Position,
                                (humanoidRootPart.Position - camera.CFrame.Position).Unit * 1000,
                                raycastParams
                            )
                            
                            if raycastResult and raycastResult.Instance:IsDescendantOf(character) then
                                
                                local screenPoint, onScreen = camera:WorldToViewportPoint(humanoidRootPart.Position)
                                
                                if onScreen then
                                    local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - mousePos).Magnitude
                                    
                                    if distance < closestDistance then
                                        closestDistance = distance
                                        closestTarget = player
                                    end
                                end
                            end
                        else
                            
                            local screenPoint, onScreen = camera:WorldToViewportPoint(humanoidRootPart.Position)
                            
                            if onScreen then
                                local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - mousePos).Magnitude
                                
                                if distance < closestDistance then
                                    closestDistance = distance
                                    closestTarget = player
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    return closestTarget
end


_F.AimAtTarget = function(target)
    if not target or not target.Character then return end
    
    local camera = Workspace.CurrentCamera
    local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return end
    
    local targetPosition = targetRoot.Position
    
    
    local targetVelocity = targetRoot.Velocity
    local distance = (targetPosition - camera.CFrame.Position).Magnitude
    local travelTime = distance / 1000 -- Примерная скорость пули
    local predictedPosition = targetPosition + targetVelocity * travelTime
    
    
    local currentCFrame = camera.CFrame
    local targetCFrame = CFrame.lookAt(currentCFrame.Position, predictedPosition + Vector3.new(0, 2, 0)) -- Прицел в грудь
    
    local smoothCFrame = currentCFrame:Lerp(targetCFrame, 1 / _F.AimbotSmoothness)
    
    
    camera.CFrame = smoothCFrame
end


_F.StartAimbot = function()
    if _F.AimbotConnection then
        _F.AimbotConnection:Disconnect()
    end
    
    _F.AimbotConnection = RunService.RenderStepped:Connect(function()
        if not _F.AimbotEnabled then return end
        
        -- Проверяем нажата ли кнопка прицеливания
        if UserInputService:IsMouseButtonPressed(_F.AimbotKey) then
            _F.AimbotTarget = _F.FindAimbotTarget()
            
            if _F.AimbotTarget then
                _F.AimAtTarget(_F.AimbotTarget)
            end
        else
            _F.AimbotTarget = nil
        end
    end)
end


_F.ToggleAimbot = function(enabled)
    _F.AimbotEnabled = enabled
    
    if enabled then
        _F.StartAimbot()
        print("Aimbot: ENABLED")
        print("Hold RMB to aim at killers")
    else
        if _F.AimbotConnection then
            _F.AimbotConnection:Disconnect()
            _F.AimbotConnection = nil
        end
        _F.AimbotTarget = nil
        print("Aimbot: DISABLED")
    end
end

_F.UpdateAimbotFOV = function(value)
    _F.AimbotFOV = value
    print("Aimbot FOV: " .. value)
end

_F.UpdateAimbotSmoothness = function(value)
    _F.AimbotSmoothness = value
    print("Aimbot Smoothness: " .. value)
end

_F.ToggleAimbotTeamCheck = function(enabled)
    _F.AimbotTeamCheck = enabled
    print("Aimbot Team Check: " .. (enabled and "ENABLED" or "DISABLED"))
end

_F.ToggleAimbotVisibleCheck = function(enabled)
    _F.AimbotVisibleCheck = enabled
    print("Aimbot Visible Check: " .. (enabled and "ENABLED" or "DISABLED"))
end


_F.SilentAimEnabled = false
_F.SilentAimConnection = nil

_F.StartSilentAim = function()
    if _F.SilentAimConnection then
        _F.SilentAimConnection:Disconnect()
    end
    
    _F.SilentAimConnection = RunService.Heartbeat:Connect(function()
        if not _F.SilentAimEnabled then return end
        
        local target = _F.FindAimbotTarget()
        if target and target.Character then
            local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
            if targetRoot then
                
                local camera = Workspace.CurrentCamera
                local screenPoint = camera:WorldToScreenPoint(targetRoot.Position)
                
                
                
            end
        end
    end)
end

_F.ToggleSilentAim = function(enabled)
    _F.SilentAimEnabled = enabled
    
    if enabled then
        _F.StartSilentAim()
        print("Silent Aim: ENABLED")
    else
        if _F.SilentAimConnection then
            _F.SilentAimConnection:Disconnect()
            _F.SilentAimConnection = nil
        end
        print("Silent Aim: DISABLED")
    end
end


_F.TriggerbotEnabled = false
_F.TriggerbotConnection = nil

_F.StartTriggerbot = function()
    if _F.TriggerbotConnection then
        _F.TriggerbotConnection:Disconnect()
    end
    
    _F.TriggerbotConnection = RunService.Heartbeat:Connect(function()
        if not _F.TriggerbotEnabled then return end
        
        local target = _F.FindAimbotTarget()
        if target and target.Character then
            
            local character = LocalPlayer.Character
            if character then
                local tool = character:FindFirstChildOfClass("Tool")
                if tool then
                    
                    if string.find(string.lower(tool.Name), "twist") or 
                       string.find(string.lower(tool.Name), "fate") or 
                       string.find(string.lower(tool.Name), "pistol") or
                       string.find(string.lower(tool.Name), "gun") then
                       
                        tool:Activate()
                    end
                end
            end
        end
    end)
end

_F.ToggleTriggerbot = function(enabled)
    _F.TriggerbotEnabled = enabled
    
    if enabled then
        _F.StartTriggerbot()
        print("Triggerbot: ENABLED")
    else
        if _F.TriggerbotConnection then
            _F.TriggerbotConnection:Disconnect()
            _F.TriggerbotConnection = nil
        end
        print("Triggerbot: DISABLED")
    end
end

_F.CreateToggle("Aimbot (Hold RMB)", false, _F.ToggleAimbot, _F.GameFeaturesFrame)
_F.CreateSlider("Aimbot FOV", 1, 200, 50, _F.UpdateAimbotFOV, _F.GameFeaturesFrame)
_F.CreateSlider("Aimbot Smoothness", 1, 20, 10, _F.UpdateAimbotSmoothness, _F.GameFeaturesFrame)
_F.CreateToggle("Team Check (Killer Only)", true, _F.ToggleAimbotTeamCheck, _F.GameFeaturesFrame)
_F.CreateToggle("Visible Check", true, _F.ToggleAimbotVisibleCheck, _F.GameFeaturesFrame)
_F.CreateToggle("Triggerbot", false, _F.ToggleTriggerbot, _F.GameFeaturesFrame)
_F.CreateToggle("Silent Aim", false, _F.ToggleSilentAim, _F.GameFeaturesFrame)


_F.ToggleCrosshair = function(enabled)
    _F.CrosshairEnabled = enabled
    _F.CrosshairFrame.Visible = enabled
    print("Crosshair: " .. (enabled and "ENABLED" or "DISABLED"))
end

_F.CreateToggle("Crosshair", false, _F.ToggleCrosshair, _F.VisualSettingsFrame)

_F.CreateToggle("Rotate Person", false, _F.ToggleRotatePerson, _F.GameFeaturesFrame)
_F.CreateSlider("Rotate Speed", 0, 1000, 100, _F.UpdateRotateSpeed, _F.GameFeaturesFrame)

_F.CreateToggle("Walk Speed", false, _F.ToggleWalkSpeed, _F.GameFeaturesFrame)
_F.CreateSlider("Walk Speed Value", 16, 500, 16, _F.UpdateWalkSpeedValue, _F.GameFeaturesFrame)

_F.CreateToggle("JumpPower", false, _F.MovementFunctions.ToggleJumpPower, _F.GameFeaturesFrame)
_F.CreateSlider("JumpPower Value", 0, 500, 50, _F.MovementFunctions.UpdateJumpPowerValue, _F.GameFeaturesFrame)

_F.CreateToggle("Fly (WASD+Space+Shift)", false, _F.ToggleFly, _F.GameFeaturesFrame)
_F.CreateSlider("Fly Speed", 0, 500, 50, function(value)
    _F.FlySpeedValue = value
    print("Fly Speed: " .. value)
end, _F.GameFeaturesFrame)

_F.CreateToggle("Third Person View (Killer)", false, _F.ToggleThirdPerson, _F.GameFeaturesFrame)
_F.CreateToggle("Noclip", false, _F.ToggleNoclip, _F.GameFeaturesFrame)
_F.CreateToggle("God Mode", false, _F.ToggleGodMode, _F.GameFeaturesFrame)
_F.CreateToggle("Invisible", false, _F.ToggleInvisible, _F.GameFeaturesFrame)
_F.CreateToggle("AntiStun", false, _F.ToggleAntiStun, _F.GameFeaturesFrame)
_F.CreateToggle("AntiGrab", false, _F.ToggleAntiGrab, _F.GameFeaturesFrame)
_F.CreateToggle("100% Escape Chance", false, _F.ToggleMaxEscapeChance, _F.GameFeaturesFrame)
_F.CreateToggle("Grab Killer", false, _F.ToggleGrabKiller, _F.GameFeaturesFrame)
_F.CreateToggle("Rapid Fire (Twist of Fate)", false, _F.ToggleRapidFire, _F.GameFeaturesFrame)
_F.CreateToggle("Disable Twist Animations", false, _F.ToggleTwistAnimations, _F.GameFeaturesFrame)

_F.CreateButton("Teleport to Player", function()
    _F.OpenTeleportMenu()
end, _F.GameFeaturesFrame)

-- VISUAL SETTINGS
_F.CreateToggle("No Fog", false, _F.ToggleNoFog, _F.VisualSettingsFrame)
_F.CreateToggle("Custom Time", false, _F.ToggleTime, _F.VisualSettingsFrame)
_F.CreateSlider("Time Value", 0, 24, 12, function(value)
    _F.TimeValue = value
    if _F.TimeEnabled then
        Lighting.ClockTime = value
    end
end, _F.VisualSettingsFrame)

_F.CreateToggle("Map Color", false, _F.ToggleMapColor, _F.VisualSettingsFrame)
_F.CreateHSVColorPicker("Map Color Picker", _F.MapColor, function(color)
    _F.MapColor = color
    if _F.MapColorEnabled then
        Lighting.Ambient = color
        Lighting.OutdoorAmbient = color
    end
end, _F.VisualSettingsFrame)

_F.CreateSlider("Map Saturation", -1, 2, 1, function(value)
    _F.MapColorSaturation = value
    if _F.MapColorEnabled then
        if not Lighting:FindFirstChild("ColorCorrection") then
            local colorCorrection = Instance.new("ColorCorrectionEffect")
            colorCorrection.Name = "ColorCorrection"
            colorCorrection.Saturation = value
            colorCorrection.Parent = Lighting
        else
            Lighting.ColorCorrection.Saturation = value
        end
    end
end, _F.VisualSettingsFrame)

_F.ToggleMenu = function()
    _F.MenuOpen = not _F.MenuOpen
    
    local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    
    if _F.MenuOpen then
        local tween = TweenService:Create(_F.MainFrame, tweenInfo, {
            Position = UDim2.new(0, 20, 0, 100)
        })
        tween:Play()
        _F.UnlockCursor()
        print("Menu: OPENED")
    else
        local tween = TweenService:Create(_F.MainFrame, tweenInfo, {
            Position = UDim2.new(0, -470, 0, 100)
        })
        tween:Play()
        print("Menu: CLOSED")
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == Enum.KeyCode.F1 then
        _F.ToggleMenu()
    end
end)

_F.CreateSimpleNotification = function()
    local Notification = Instance.new("TextLabel")
    Notification.Name = "MenuHint"
    Notification.Size = UDim2.new(0, 200, 0, 40)
    Notification.Position = UDim2.new(0.5, -175, 0.5, -40)
    Notification.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Notification.BackgroundTransparency = 0.5
    Notification.Text = "Open Menu: RightShift"
    Notification.TextColor3 = Color3.fromRGB(255, 255, 255)
    Notification.TextSize = 14
    Notification.Font = Enum.Font.GothamBold
    Notification.TextStrokeTransparency = 0
    Notification.ZIndex = 1000
    Notification.Parent = _F.ScreenGui
    
    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 8)
    Corner.Parent = Notification
    
    Notification.Position = UDim2.new(1, 300, 1, -50)
    
    local tweenIn = TweenService:Create(Notification, TweenInfo.new(0.7, Enum.EasingStyle.Quint, Enum.EasingDirection.Out), {
        Position = UDim2.new(1, -210, 1, -50)
    })
    tweenIn:Play()
    
    delay(5, function()
        local tweenOut = TweenService:Create(Notification, TweenInfo.new(0.7, Enum.EasingStyle.Quint, Enum.EasingDirection.In), {
            Position = UDim2.new(1, 300, 1, -50)
        })
        tweenOut:Play()
        
        tweenOut.Completed:Connect(function()
            Notification:Destroy()
        end)
    end)
end

_F.CreateTeleportMenu()

coroutine.wrap(function()
    while true do
        wait(5)
        if _F.TeleportFrame and _F.TeleportFrame.Visible then
            _F.UpdateTeleportPlayersList()
        end
    end
end)()

_F.StartGameCheckers()

delay(1.5, _F.CreateSimpleNotification)

wait(2)
_F.UnlockCursor()

delay(60, function()
    _F.UnlockCursor()
end)

_F.ToggleMenu()
